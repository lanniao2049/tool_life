人机交换方式
	GUI(Graphical User Interface)
	CLI(Command Line Interface)
语言介绍
	第一代语言，二进制语言
	第二代语言，汇编语言
	第三代语言，高级语言(C，C++,Java等)
	
SUN(Stanford University Network)	

Java计算平台分类
	JSE(Java Standard Edition)
	JEE(Java Enterprise Edition)
	JME(Java Micro Edition)

Java的主要特点
	易学
	强制面向对象
	分布式(面向网络)
	健壮性(强类型机制，异常机制，垃圾自动回收机制)
	安全性
	中立性
	解释性
	性能略高
	原生支持多线程
	
Java的特征
	面向对象（继承，封装，多态）
	健壮性(和C,C++比较)
	跨平台
	
Java两大核心机制
	JVM(Java Virtual Machine)
		
	GC(Garbage Collection)
		程序自动垃圾回收，空闲时回收，手动调用System.gc()触发回收,但是无法可控

常用名称
	Jdk(Java development kit)>Jre(Java runtime environment)>Jvm(Java virtual machine)
		
	API(Application Programming Interface)	
Java 类中名称是否可以和文件名不一致？
	有public修饰的类名称必须和文件名一致，一个类中有且最多一个public修饰类，其他类可以有多个
	
	不用public修饰的类名和类名称可以不一致

变量类型
	基本数据变量
		byte,short,int,long,float,double,boolean,char
	引用变量
		class(字符串),接口,数组

	
变量位置
	成员变量
		实例变量(不用static修饰)
		类变量(static修饰)
	局部变量
		方法内
		代码块
		形参
	
	异同：
		生命周期不同
		成员变量不需要初始化，局部变量除了形参外需要初始化
		
		
变量注意事项	
	1.先定义，在使用
	2.有作用域
	3.同一个作用域中不能重复多个变量
	
	
基本类型区别
	类型	长度			表示范围
	byte 	1byte=8bit		-128-127
	short   2byte=16bit		-2^(16-1) - 2^(16-1)-1
	int 	4byte=32bit		-2^(32-1) - 2^(32-1)-1
	long 	8byte=64bit		-2^(64-1) - 2^(64-1)-1
	
	float	4byte=32bit
	double 	8byte=64bit
	
	char	2byte=16bit
	
	整型类型默认是int,使用long类型需要10L
	浮点类型默认是double,使用float需要使用51.0f/51.0F
	
	float表示的数值的范围比long还大，为什么？？
	
	
	char类型表示
		// 一个字符
		char a='9';
		// 转义字符
		char b='\n';
		// unicode
		char c =11;
		char e = '\u0123';
		// 一个字符
		char d = '中';
		char d1 =5;
		char d2 = '5';
		
		System.out.println(d1);
		
	boolean
		只能是false和true，不能是null
		
		JVM中true用1表示，false用0表示
		
编码
	ASCII
		一共规定128个字符
	Unicode
		
	
数据转换
	byte,short,char不能相互转换，只能转换为int在操作
	byte a1=125;
	short a2=45;
	char a3= 'a';
	
	a1+a2,
	a1+a3,
	a2+a3
	
	都是int接受
	//
	int d = 128;
    byte e = (byte) d;
	System.out.println(e);
	
	// 为什么可以？默认是int,提升到long
	long a1  = 123122;
	// 不可以的，因为默认int已经超出范围，必须加上后缀l/L
    long a2 = 2343243243243243;
    //	可以的
	long a3 = 2343243243243243l;
	
String	
	引用类型
	区分+到底是加法运算还是连接字符串操作关键看+前后两边是否是字符串

		int num1 = 19;
        char cha1 = 'a';
        String str1 = "hello";
        System.out.println(num1 + cha1 + str1);
        System.out.println(num1 + str1 + cha1);
        System.out.println(num1 + (cha1 + str1));
        System.out.println('a' + '\n' + '*');
        System.out.println('b' + '\n' + "good");
        System.out.println('b' + "\n" + "good");
        System.out.println("b" + "\n" + "good");	
		
进制之间的转换

	二进制
		0b01/0B01
	八进制
		01/02/07
	十六进制
		0x123/0X123
	
	二进制
		0 1 0 1 0 0 0 0
		首位是符合位 0 表示正数，1表示负数
		
		
	正数的原码，反码，补码一样，三码合一
	负数的原码，就是正数原码基础上符合位变为1 
	负数的反码，除符号位，其他全部取反
	负数的补码，反码+1
	
	计算机底层中都以补码的方式存储数据的
	
	
	10进制--》2进制
		除2取余的逆
		
		2 13 
		   6			1
			 3			0
			   1		1
			   0		1 
	二进制-->八进制 
		0000 0000 0000 0000
			三个一进
	二进制-->十六进制
			四个一进
			
	八进制转二进制
		0231
			010	011 001
	十六进制转二进制	
		0x234
			0010 0011 0100
			
	十进制与八进制，十六进制转换，可以通过中间二进制桥梁

运算符
	int num1 =12;
	int num2 = 5;
	double result1 = num1 / num2;
	double result2 = num1 / num2 +0.0;
	double result3 = num1 / (num2+0.0);
	double result4 = (double)num1/num2;
	double result5 = (double)(num1/num2);
	
	// 取模结果与被取模的符号位一致

        int num1 = 12;
        int num2 = 5;

        System.out.println("num1%num2 "+num1%num2);

        int m1 = -12;
        int n1 = 5;
        System.out.println("m1%n1 "+m1%n1);

        int m2 = 12;
        int n2 = -5;
        System.out.println("m2%n2 "+m2%n2);

        int m3 = -12;
        int n3 = -5;
        System.out.println("m3%n3 "+m3%n3);
		
	// 自增计算
        short a1 = 10;
        // a1怎么实现+1的操作
//        a1 = a1+1;
//        a1+1;
        a1 = (short)( a1+1);
        // 使用自增运算，数据类型在原来的基础上不会改变(二进制的基础上+1)
        a1++;
        System.out.println(a1);

        byte b1 = 127;
        b1++;
        System.out.println(b1);
		
		byte c1 = -128;
        c1--;
        System.out.println(c1);
		
		// 一个三位数，分别输出百位数，十位数，个位数
        int number = 823;
        int bai = number/100;
        int shi = number%100/10;
        int ge = number%10;
        System.out.println("百位数："+bai+",十位数："+shi+",个数数："+ge);
		
		
	// 赋值运算
        short s1 = 5;
        // n+=2 可以理解为 n = n+2;但是和真正的n+2还是不一样的
//        s1 = s1+2;  编译失败
        // 使用下面的不改变数据的基本类型
        s1+=2;
		
		// 思考题1
        short s1 = 5;
        /*
        s1 = s1+2;
        s1+2;
        两者有什么区别？
        */
        // 思考题2
        int a = 1;
        a*=0.1;
        System.out.println(a);
        a++;
        System.out.println(a);
        // 思考题3
        int m =2;
        int n =3;
        n*=m++;
        System.out.println("n="+n+",m="+m);
        // 思考题4
        int n1 = 10;
        n1+=(n1++)+(++n1);
        System.out.println(n1);
		
		  // 经典自增面试题
    public static void  test1(){
        boolean x = true;
        boolean y = false;
        short z =42;
//        if (y==true)
        if ((z++==42)&(y=true))z++;
        if (x=false||(++z==45))z++;
        System.out.println(z);
    }
	
位运算符
	<< 左移
		空位补0，高位丢弃
	>> 右移
		高位为0时，右移后，高位补0
		高位为1时，右移后，高位补1
	>>> 无符号右移
		被移位二级制无论是0或者1，空缺位都是0
	&  二进制与操作，都为1则为1，否则为0
	|  二级制或操作，只要有一个1则为1，全部为0才为0
	^  二级制异或操作，不同才为1，相同则为0
	
	/**
     * 经典a,b交换
     */
    public static void test2(){
        int a =10;
        int b =20;
        System.out.println("a = "+a+",b="+b);

        // 推荐使用该方法，使用与任何数据类型
//        int temp = a;
//        a = b;
//        b = temp;
//        System.out.println("a = "+a+",b="+b);

        // 下面的方法
        // 优点：不适用临时变量，缺点：1.有可能超出数据限制，2，仅能使用与数字类型，不能使用String等的交换
//        a = a+b;
//        b = a-b;
//        a = a -b;
//        System.out.println("a = "+a+",b="+b);

        // 使用^运算 ，仅使用与整数类型
        a = a^b;
        b = a^b;
        a = a^b;
        System.out.println("a = "+a+",b="+b);	
		
		
数组 
	1.数组存放同样类型的数据(可以是基本类型的也可以是引用类型的数据)
	2.数组存放数据有一定的顺序
	3.数组在内存中的空间是连续的
	4.数组空间大小一旦确定不可更改
	
	
	public static void test4(){
        // 动态初始化，堆，栈，内存分布情况
        int[] a = new int[5];
        // 静态初始化
        int[] a1 = new int[]{2, 3, 4, 5};
        // 怎么理解该情况
        int[] a2 = {};
        System.out.println("a2 " + a2);
        // 类型推断
        int[] a3 = {1,2,5,};
        int[] a4;
        a4 = new int[4];
        // 下面先声明，后初始化为什么不能使用类型推断
//        int[] a5;
//        a5 = {1,2,3};
    }