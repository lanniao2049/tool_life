人机交换方式
	GUI(Graphical User Interface)
	CLI(Command Line Interface)
语言介绍
	第一代语言，二进制语言
	第二代语言，汇编语言
	第三代语言，高级语言(C，C++,Java等)
	
SUN(Stanford University Network)	

Java计算平台分类
	JSE(Java Standard Edition)
	JEE(Java Enterprise Edition)
	JME(Java Micro Edition)

Java的主要特点
	易学
	强制面向对象
	分布式(面向网络)
	健壮性(强类型机制，异常机制，垃圾自动回收机制)
	安全性
	中立性
	解释性
	性能略高
	原生支持多线程
	
Java的特征
	面向对象（继承，封装，多态）
	健壮性(和C,C++比较)
	跨平台
	
Java两大核心机制
	JVM(Java Virtual Machine)
		
	GC(Garbage Collection)
		程序自动垃圾回收，空闲时回收，手动调用System.gc()触发回收,但是无法可控

常用名称
	Jdk(Java development kit)>Jre(Java runtime environment)>Jvm(Java virtual machine)
		
	API(Application Programming Interface)	
Java 类中名称是否可以和文件名不一致？
	有public修饰的类名称必须和文件名一致，一个类中有且最多一个public修饰类，其他类可以有多个
	
	不用public修饰的类名和类名称可以不一致

变量类型
	基本数据变量
		byte,short,int,long,float,double,boolean,char
	引用变量
		class(字符串),接口,数组

	
变量位置
	成员变量
		实例变量(不用static修饰)
		类变量(static修饰)
	局部变量
		方法内
		代码块
		形参
	
	异同：
		生命周期不同
		成员变量不需要初始化，局部变量除了形参外需要初始化
		
		
变量注意事项	
	1.先定义，在使用
	2.有作用域
	3.同一个作用域中不能重复多个变量
	
	
基本类型区别
	类型	长度			表示范围
	byte 	1byte=8bit		-128-127
	short   2byte=16bit		-2^(16-1) - 2^(16-1)-1
	int 	4byte=32bit		-2^(32-1) - 2^(32-1)-1
	long 	8byte=64bit		-2^(64-1) - 2^(64-1)-1
	
	float	4byte=32bit
	double 	8byte=64bit
	
	char	2byte=16bit
	
	整型类型默认是int,使用long类型需要10L
	浮点类型默认是double,使用float需要使用51.0f/51.0F
	
	float表示的数值的范围比long还大，为什么？？
	
	
	char类型表示
		// 一个字符
		char a='9';
		// 转义字符
		char b='\n';
		// unicode
		char c =11;
		char e = '\u0123';
		// 一个字符
		char d = '中';
		char d1 =5;
		char d2 = '5';
		
		System.out.println(d1);
		
	boolean
		只能是false和true，不能是null
		
		JVM中true用1表示，false用0表示
		
编码
	ASCII
		一共规定128个字符
	Unicode
		
	
数据转换
	byte,short,char不能相互转换，只能转换为int在操作
	byte a1=125;
	short a2=45;
	char a3= 'a';
	
	a1+a2,
	a1+a3,
	a2+a3
	
	都是int接受
	//
	int d = 128;
    byte e = (byte) d;
	System.out.println(e);
	
	// 为什么可以？默认是int,提升到long
	long a1  = 123122;
	// 不可以的，因为默认int已经超出范围，必须加上后缀l/L
    long a2 = 2343243243243243;
    //	可以的
	long a3 = 2343243243243243l;
	
String	
	引用类型
	区分+到底是加法运算还是连接字符串操作关键看+前后两边是否是字符串

		int num1 = 19;
        char cha1 = 'a';
        String str1 = "hello";
        System.out.println(num1 + cha1 + str1);
        System.out.println(num1 + str1 + cha1);
        System.out.println(num1 + (cha1 + str1));
        System.out.println('a' + '\n' + '*');
        System.out.println('b' + '\n' + "good");
        System.out.println('b' + "\n" + "good");
        System.out.println("b" + "\n" + "good");	
		
进制之间的转换

	二进制
		0b01/0B01
	八进制
		01/02/07
	十六进制
		0x123/0X123
	
	二进制
		0 1 0 1 0 0 0 0
		首位是符合位 0 表示正数，1表示负数
		
		
	正数的原码，反码，补码一样，三码合一
	负数的原码，就是正数原码基础上符合位变为1 
	负数的反码，除符号位，其他全部取反
	负数的补码，反码+1
	
	计算机底层中都以补码的方式存储数据的
	
	
	10进制--》2进制
		除2取余的逆
		
		2 13 
		   6			1
			 3			0
			   1		1
			   0		1 
	二进制-->八进制 
		0000 0000 0000 0000
			三个一进
	二进制-->十六进制
			四个一进
			
	八进制转二进制
		0231
			010	011 001
	十六进制转二进制	
		0x234
			0010 0011 0100
			
	十进制与八进制，十六进制转换，可以通过中间二进制桥梁

运算符
	int num1 =12;
	int num2 = 5;
	double result1 = num1 / num2;
	double result2 = num1 / num2 +0.0;
	double result3 = num1 / (num2+0.0);
	double result4 = (double)num1/num2;
	double result5 = (double)(num1/num2);
	
	// 取模结果与被取模的符号位一致

        int num1 = 12;
        int num2 = 5;

        System.out.println("num1%num2 "+num1%num2);

        int m1 = -12;
        int n1 = 5;
        System.out.println("m1%n1 "+m1%n1);

        int m2 = 12;
        int n2 = -5;
        System.out.println("m2%n2 "+m2%n2);

        int m3 = -12;
        int n3 = -5;
        System.out.println("m3%n3 "+m3%n3);
		
	// 自增计算
        short a1 = 10;
        // a1怎么实现+1的操作
//        a1 = a1+1;
//        a1+1;
        a1 = (short)( a1+1);
        // 使用自增运算，数据类型在原来的基础上不会改变(二进制的基础上+1)
        a1++;
        System.out.println(a1);

        byte b1 = 127;
        b1++;
        System.out.println(b1);
		
		byte c1 = -128;
        c1--;
        System.out.println(c1);
		
		// 一个三位数，分别输出百位数，十位数，个位数
        int number = 823;
        int bai = number/100;
        int shi = number%100/10;
        int ge = number%10;
        System.out.println("百位数："+bai+",十位数："+shi+",个数数："+ge);
		
		
	// 赋值运算
        short s1 = 5;
        // n+=2 可以理解为 n = n+2;但是和真正的n+2还是不一样的
//        s1 = s1+2;  编译失败
        // 使用下面的不改变数据的基本类型
        s1+=2;
		
		// 思考题1
        short s1 = 5;
        /*
        s1 = s1+2;
        s1+2;
        两者有什么区别？
        */
        // 思考题2
        int a = 1;
        a*=0.1;
        System.out.println(a);
        a++;
        System.out.println(a);
        // 思考题3
        int m =2;
        int n =3;
        n*=m++;
        System.out.println("n="+n+",m="+m);
        // 思考题4
        int n1 = 10;
        n1+=(n1++)+(++n1);
        System.out.println(n1);
		
		  // 经典自增面试题
    public static void  test1(){
        boolean x = true;
        boolean y = false;
        short z =42;
//        if (y==true)
        if ((z++==42)&(y=true))z++;
        if (x=false||(++z==45))z++;
        System.out.println(z);
    }
	
位运算符
	<< 左移
		空位补0，高位丢弃
	>> 右移
		高位为0时，右移后，高位补0
		高位为1时，右移后，高位补1
	>>> 无符号右移
		被移位二级制无论是0或者1，空缺位都是0
	&  二进制与操作，都为1则为1，否则为0
	|  二级制或操作，只要有一个1则为1，全部为0才为0
	^  二级制异或操作，不同才为1，相同则为0
	
	/**
     * 经典a,b交换
     */
    public static void test2(){
        int a =10;
        int b =20;
        System.out.println("a = "+a+",b="+b);

        // 推荐使用该方法，使用与任何数据类型
//        int temp = a;
//        a = b;
//        b = temp;
//        System.out.println("a = "+a+",b="+b);

        // 下面的方法
        // 优点：不适用临时变量，缺点：1.有可能超出数据限制，2，仅能使用与数字类型，不能使用String等的交换
//        a = a+b;
//        b = a-b;
//        a = a -b;
//        System.out.println("a = "+a+",b="+b);

        // 使用^运算 ，仅使用与整数类型
        a = a^b;
        b = a^b;
        a = a^b;
        System.out.println("a = "+a+",b="+b);	
		
		
数组 
	1.数组存放同样类型的数据(可以是基本类型的也可以是引用类型的数据)
	2.数组存放数据有一定的顺序
	3.数组在内存中的空间是连续的
	4.数组空间大小一旦确定不可更改
	
	
	public static void test4(){
        // 动态初始化，堆，栈，内存分布情况
        int[] a = new int[5];
        // 静态初始化
        int[] a1 = new int[]{2, 3, 4, 5};
        // 怎么理解该情况
        int[] a2 = {};
        System.out.println("a2 " + a2);
        // 类型推断
        int[] a3 = {1,2,5,};
        int[] a4;
        a4 = new int[4];
        // 下面先声明，后初始化为什么不能使用类型推断
//        int[] a5;
//        a5 = {1,2,3};
    }
	
二维数组
	
	
	public static void  test1(){
        // 二维数组
        int[][] a1 = new int[5][4];
        int[][] a2 = {{1,2,3},{1,2},{},{5}};
        int[][] a3;
        a3 = new int[12][];
//        int[][] a4;
//        a4 = {{1,2},{2,3},{4,5}}

        String[][] st1 = new String[5][];
        System.out.println(st1);
        System.out.println(st1[0]);
        System.out.println(a3[1]);
        System.out.println(a2[1]);
		System.out.println(a2[0].length);
    }

数组 
	二维数组
	// 如何理解y的赋值
	int[]x,y[];
	
	public static void test2(){
        // 特别要注意x是一维数组，y是二位数组
        int[]x,y[],z;
        x = new int[]{1, 2, 3, 4};
        y = new int[][]{{1, 2, 3,}, {2, 3}};
    }

数组的算法

	/**
     * 杨辉三角，首尾元素都为1，其他元素满足y[i][j]=y[i-1][y-1]+y[i-1][y]
     */
    public static void test4(){
        // 1.杨辉三角初始化
        int[][] yangHui = new int[10][];
//        yangHui[0] = new int[1];
//        yangHui[1] = new int[2];
//        yangHui[2] = new int[3];

        // 2.赋值
        for (int i = 0; i < yangHui.length; i++) {
            // 2.1初始化数组
            yangHui[i] = new int[i+1];
            // 2.2首尾元素赋值
            yangHui[i][0] = 1;
            yangHui[i][i] = 1;
            
            // 2.3其他数据元素赋值
            if (i>1){
                for (int j = 1; j < yangHui[i].length-1; j++) {
                    yangHui[i][j] = yangHui[i-1][j-1] + yangHui[i-1][j];
                }
            }
        }
        // 3.遍历所有元素
        for (int i = 0; i < yangHui.length; i++) {
            for (int j = 0; j < yangHui[i].length; j++) {
                System.out.print(yangHui[i][j]+"\t");
            }
            System.out.println();
        }
    }
	
	/**
     * 一个为10的数组，元素是两位数的正整数随机数，求该数组的最大值，最小值，和以及平均值
     * [10,99] ，计算公式(int)(Math.random()*(99-10+1)+10)
     */
    public static void test5(){
        int[] numbers = new int[10];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = (int) (Math.random() * (99 - 10 + 1) + 10);
            System.out.print(numbers[i]+"\t");
        }
        int maxValue = numbers[0];
        for (int i = 0; i < numbers.length; i++) {
            if (maxValue<numbers[i]){
                maxValue = numbers[i];
            }
        }
        System.out.println();
        System.out.println("最大值是："+maxValue);
        int minValue = numbers[0];
        for (int i = 0; i < numbers.length; i++) {
            if (minValue>numbers[i]){
                minValue = numbers[i];
            }
        }
        System.out.println("最小值是："+minValue);

        int sum = 0;
        for (int i = 0; i < numbers.length; i++) {
            sum += numbers[i];
        }
        System.out.println("和是："+sum);

        int avg = sum/numbers.length;
        System.out.println("平均值是："+avg);
    }
	
	/**
     * 数组之间相互赋值，复制的区别
     */
    public static void test6(){
        int[] arry1 = new int[]{1,9,8,23,84,43,29};
        for (int i = 0; i < arry1.length; i++) {
            System.out.print(arry1[i]+"\t");
        }
        System.out.println();
        int[] arry2 = arry1;
//        // 修改数组arr2中偶数索引为索引值，例如 i[0]=0,i[2]=2
//        for (int i = 0; i < arry2.length; i++) {
//            if (i%2==0){
//                arry2[i] = i;
//            }
//        }

        // 复制
        int[] arry3 = new int[arry1.length];
        for (int i = 0; i < arry3.length; i++) {
            arry3[i] = arry1[i];
        }

        for (int i = 0; i < arry1.length; i++) {
            System.out.print(arry1[i]+"\t");
        }
    }
	
	/**
     * 数组元素反转
     */
    public static void test7(){
        String[] str1 = new String[] {"JJ","DD","BB","AA","LL","GG","WW","TT","NN","UU","II","RR"};
        // 第一种方案 temp临时变量
//        for (int i = 0; i < str1.length/2; i++) {
//            String temp = str1[i];
//            str1[i] = str1[str1.length-1-i];
//            str1[str1.length-1-i] = temp;
//        }
//        for (int i = 0; i < str1.length; i++) {
//            System.out.print(str1[i]+"\t");
//        }
//        System.out.println();

        // 第二种方案 从两边向中间比较
        for (int i = 0,j= str1.length-1;i<j;i++,j--){
            String temp = str1[i];
            str1[i] = str1[j];
            str1[j] = temp;
        }

        for (int i = 0; i < str1.length; i++) {
            System.out.print(str1[i]+"\t");
        }
        System.out.println();
    }
	
	 /**
     * 数组查找方法，线性查找，二分法查找
     */
    public static void test8(){
        String[] str = new String[]{"JJ","DD","BB","AA","LL","GG","WW","TT","NN","UU","II","RR"};

        // 线性查找
        String dest = "GG";
        boolean isFlag = true;
        for (int i = 0; i < str.length; i++) {
            if (dest.equals(str[i])){
                System.out.println("查找到指定元素的坐标是 " + i);
                isFlag = false;
                break;
            }
        }
        if (isFlag) {
            System.out.println("没有查找到指定的元素");
        }
    }


	/**
     * 二分法查找，注意使用该二分法必须按照一定的顺序排序后才可以使用
     */
    public static void test9(){
        int[] num = {-89,-56,-45,-38,-21,-9,12,24,36,48,59,66,78,83,91,99};
        int dest = 36;
        // 首位索引
        int head = 0;
        // 尾位索引
        int end = num.length - 1;
        boolean isFlag = true;
        while (head <= end){
            int middle = (head + end)/2;
            if (dest == num[middle]){
                System.out.println("找到目标数据元素，位置是 " + middle);
                isFlag = false;
                break;
            } else if (num[middle]>dest){
                end = middle -1;
            } else {
                // num[middle]<dest
                head = middle+1;
            }
        }
        if (isFlag) {
            System.out.println("没有查找到该目标元素！");
        }
    }
	
	
	
	// 6个正整数 从随机1-30选取，各个元素都不相同
	  
	 
	// 回形针数组样例
	
	

算法优劣的标注
	时间复杂度
	空间复杂度
	稳定性

	/**
     * 经典算法：冒泡排序，相邻的元素依次比较，前面的数据比后面的数据大则交换，依次运算
     */
    public static void test10(){
        int[] numbers = {-12,-23,-46,9,87,23,-13,-34,-7,43,12,89,99};
        // 大伦次数
        for (int i = 0; i < numbers.length-1; i++) {
            // 每次大伦次下的小对比次数
            for (int j = 0;j< numbers.length-1-i;j++){
                // 判断相邻两个元素的大小关系，前面元素大于后面的元素则交换
                if (numbers[j]>numbers[j+1]){
                    int tmp = numbers[j];
                    numbers[j] = numbers[j+1];
                    numbers[j+1] = tmp;
                }
            }
        }
        // 遍历所有数据
        for (int i = 0; i < numbers.length; i++) {
            System.out.print(numbers[i]+"\t");
        }
    }
	
各个算法之间的对比
	时间复杂度
	空间复杂度
	稳定性
	
	
	最常使用的算法是冒泡排序，快速排序，堆排序等
	
	
经典算法必会
	十种经典算法，杨辉三角，回形针数组
		冒泡排序，选择排序，快速排序，堆排序，插入排序，归并排序等
	
数组常见异常
	ArrayIndexOfBoundsException
	NullPointerException
	

java对象
	类与对象
		类是对象的抽象，对象是类的具体化。
		
	特点：
		多态，继承，封装
		
	JVM内存分布
		堆，栈，方法区，本地方法栈
	

成员变量和局部变量的区别

	相同点：
		1.都是先声明后使用
		2.都有作用域(生命周期)
		3.格式都一样 ，数据类型 变量名=变量值
	不同点：
		1.位置不同
			成员变量位于类下
			局部变量位于方法内，方法形参，构造方法内，构造方法形参，代码块中
		2.默认值不同
			成员变量有默认初始化值
				byte,short,int,long,float,double,char,boolean使用各自的默认初始值
				String,对象，类其他的默认初始化值为null
			局部变量没有初始化值，使用前必须赋值
				特殊情况：方法形参，构造器形参不需要赋值，在调用该办法的时候赋值
		3.权限修饰符不同
			成员变量可以使用private,public,缺省,protect修饰
			局部变量不可以使用权限修饰符（仅使用缺省）
		4.内存位置不同
			成员变量(非static)位于内存中的堆中
			局部变量位于内存中的栈中
		5.生命周期不同	
			成员变量生命周期和对象生命周期一致
			局部变量生命周期在方法，构造器，代码块结束消亡


方法
	权限修饰符 返回值 方法名(){
		方法体
	}

面向对象
	类的设计：属性，方法，构造器，内部类，代码块 
	面向对象的特征：封装，继承，多态 

如何理解面向对象的编程？

栈，堆是在编译是还是在运行是？
	源代码.java文件编译生成.class文件，字节文件在JVM运行时加载Load分配生成内存，即响应的栈，堆等 



如何理解万事万物皆对象
	1.在java语言范畴内，我们都将功能和结构封装到类中，通过类的实例化，调用对象的具体功能。
		Scanner,String,
		文件对象：File
		网络对象：URl
	2.在java与前端html,json,后端数据库等数据交互时，都体现类、对象。
	
匿名对象
	1.该对象没有显式命名变量名，即为匿名变量
	2.匿名对象只可调用一次
	3.使用场景 xxx.method(new Xxxx());
	

方法的重载
	
	两同一不同：
		两同：同一个类；同样的方法名称
		一不同：参数列表不同（参数类型不同，参数个数不同，参数顺序不同）
		
	判断重载依据：
		根据定义确定，与方法的修饰符，方法的返回值，形参变量名和方法体无关
		
	
	如何确定一个方法
		方法名+参数列表 
		
		如果因为方法修饰符和方法返回值不同构成重载那具体到底调用哪个方法
		
	
	可变形参
	
	
    private void method(String name){

    }

    /**
     * 1.可变个数形参方法和数组方法相同的方法不可同时存着，不构成重载
     * 2.可变个数形参参数必须位于最后
     * 3.在方法中可变形参个数最多只能有一个
     * 4.方法可变个数形参可以和方法名相同参数列表不同的共存，重载
     * 5.方法可变个数形参，可以传0个到N个同样的参数
     * @param strings
     */
    public void method(String ... strings){

    }

//    public void method(String[] args){
//
//    }

    public void method(int age,String ... strings){

    }
    // 写法错误
//    public void method(String ... strings,double salary){
//
//    }

字符串常量池
	
封装性
	体现
		1.属性私有化，获取get和set属性
			public void setAge(int age){
				this.age = age;
			}
			public int getAge(){
				return age;
			}
		2.方法私有化
		3.构造器私有化（单例模式）
		4.缺省修饰的类，包外不能调用

权限修饰符
	private 缺省 protected public

	
	各个修饰符的权限
	private  仅在同一个类中
	缺省  在同一个类中，同一个包中
	protected 同一个类中，同一个包，不同的包中
	public 同一个类中，同一个包，不同的包中，同一个工程
	
	各个修饰符可以修饰类，属性，方法，构造器，内部类

	类的修饰符只能是public 和缺省不能使用private

构造器
	
	构造器的重载	
	
属性赋值的先后顺序
	默认初始化
	显示初始化
	构造器赋值
	set设置
	
this关键字的使用
	
	this是当前对象，可以修饰属性，方法 
	
	this可以修饰构造器
	
	构造器下最多只能有一个this调用其他的构造器，并且调用this的构造器必须位于方式的首行
	
继承 
	extends
	好处：
		1.减少冗余，提供代码复用性
		2.便于扩展
		3.多态性
		
	子类继承父类，一定继承父类的所以属性和方法
		
	父类的私有属性，私有方法，子类继承了吗？
		
		继承，子类由于权限修饰的问题不能调用
		
	规定：
		1.一个类可以有多个子类继承
		2.一个类有且最多只有一个父类，单继承
		3.子父类是相对
		4.子类获取父类和所有间接父类的方法和属性
		
Object类
	1.所有的类都直接或者间接的继承java.lang.Object类
	2.所有的类都继承java.lang.Object类的方法和属性
		

重写(overide)
	子类继承父类，覆盖父类的方法（方法名相同和参数列表相同）
	
	规定：	
		1.重写的子类和父类方法名称和参数列表相同
		2.权限修饰重写的子类不小于父类的权限修饰符
			注意：如果父类权限是private则不能重写
		3.返回值 
			如果父类是void,则子类必须也是void
			如果父类是基本类型，则子类必须也是相同的基本类型
			如果父类是A类型，则子类必须是对象或者其子类，比如父类是Object,子类是String
		4.重写的子类的异常不能大于父类的异常，如父类异常是exception,子类可以是RuntimeException

				
		重写必须是子类和父类都是非static修饰，static修饰的方法是类方法不能被重写，同样的方法父类用static，子类必须也用static
		
super
	子类和父类之间的关系
	
	super可以调用父类属性，方法，构造器 
		super.age 
		super.eat(name);
		super(age,name);
	子类的构造器调用父类的构造器使用super必须位于首行
	在构造器中this(形参)和super(形参)只能二选一
	在构造器没有显式的调用super，默认的调用父类无参构造器
	

子类对象实例化的过程
	1.从执行结果上看：
		子类继承父类，就可以获取父类声明的属性和方法
		创建子类对象，在堆空间就可以获取父类的属性
	2.从执行过程上看：
		当我们创建子类对象，一定会直接或者间接的调用父类的构造器，直到调用到
		java.lang.Object类构造器结束，正因为加载了所有的父类构造器，所有在内存空间上
		可以看到的父类的结构，子类可以考虑调用。
		
	特别说明：
		子类创建对象，到底创建了几个对象？
		子类创建对象，虽然调用多个父类构造器，但是创建对象只new 一个(new 关键字)

多态		
	父类的引用指向子类的对象
	Person p = new Man();
	p.eat();
	编译期只能调用父类的方法，但是在运行期调用的是子类的方法。（虚拟方法调用）
	编译看左边，运行看右边
		
	对象的多态，不适用声明的属性，只使用方法，都是编译看左边
	Person p = new Woman();
	p.age = 1; // 该属性指的是Person的属性
	
	
	重载在编译期已经可以确定调用那个方法了是早绑定，静态绑定，不是多态
	
	重写只有在解析器解释的时候才能确定调用那个，是晚绑定，动态绑定，是多态
	
多态中向下类型转换
	父类型不能调用子类特有的属性和方法，编译期看左边父类
	有了对象的多态后，内存中实际上加载了子类特有的属性和方法，但是变量名声明为父类，
	编译期，只能调用父类的属性和方法。子类特有的属性和方法不能调用。
	Person p = new Man();

	// 以下编译错误
	p.isSmoking = true;
	p.playGame();
	
	//那么如何调用子类特用的属性和方法？
	//
	Man man = (Man)p;
		
instance of的使用
	
	为了避免ClassCastException，使用instance of 
	a instance of A，如果true说明a是A类型
	
	经典案例 
	
	class Base{
		int count = 10;
		public void display(){
			System.out.println(this.count);
		}
	}
	class Sub extends Base{
		int count = 20;
		public void display(){
			System.out.println(this.count);
		}
	}
	
	public class SubTest{
		public void mian(String []args){
			Sub sub = new Sub();
			System.out.println(sub.count);
			sub.display();
			Base base = sub;
			System.out.println(base==sub);
			System.out.println(base.count);
			System.out.println(base.count);
		}
	}
	
	多态经典案例
	
	class Base{
		public void add(int a,int... arr){
			System.out.println("base");
		}
	}
	class Sub extends Base{
		public void add(int a,int[] arr){
			System.out.println("sub1");
		}
		
		public void add(int a,int b, int c){
			System.out.println("sub2");
		}
	}
	
	public class SubTest1{
		public static void main(String[] args){
			Base b = new Sub();
			b.add(1,2,3);
			
			Sub s = (Sub)b;
			s.add(1,2,3);
		}
	}
	
==的使用  运算符
	1、可以使用基本类型和引用类型
	2、使用基本类型比较的是存储的值是否相等（可以是不同的基本类型），引用类型比较的是存储的地址是否相等

equals的使用
	1.是方法，不能使用了基本类型，只能使用引用类型
	2.Object类中的equals实际上使用的==比较的使用引用地址是否相同，String,Date,File、包装类等
	中的equals比较的是实体内容是否相同
	3.对于自定类中的equls方法，通常我们比较的是实体内容是否相同，这样就需要我们重写
	Object类的equals方法，重写的原则就是比较实体内容是否相同
	
	
	重写的原则：
		1.对称性  a.equals(b)和b.equals(a)
		2.自反性  a.equals(a)
		3.传递性  a.equals(b),b.equals(c)则 a.equals(c)相同 
		4.任何对象.equals(null)一定是false，前提条件对象不能为null
		5.两个对象类型不一致，一定是false 
	
Object类的使用 
	
    toString()方法
		1.输出对象实际调用的是Object类的toString()
		2.Object类的toString实际输出的是
		public String toString() {
			return getClass().getName() + "@" + Integer.toHexString(hashCode());
		}
		3.String,Date,包装类等的toString()实际重写了Object的toString()方法
		4.自定义类的toString()输出，需要重写Object的toString()方法，返回的对象的实体内容
		
		特别注意：
		String a = "ssdfdf";
		a = null;
		System.out.println(a);
		System.out.println(a.toString());
		
	
包装类的使用 

	主要是基本类型有类的特征
	
	Boolean flag = new Boolean("true");
	Boolean flag1 = new Boolean(true);
	Boolean flag2 = new Boolean("True");
	Boolean flag3 = new Boolean("trueadf");
	
	经典的面试
	
	Object o1 = true ? new Integer(1):new Double(2.0);
	System.out.println(o1);
	
	Object2 o2;
	if(true)
		o2 = new Integer(1);
	else
		o2 = new Double(2.0);
	System.out.println(o2);	
	
	
	Integer i = new Integer(1);
	Integer j = new Integer(1);
	System.out.println(i==j);
	
	Integer m = 1;
	Integer n = 1;
	System.out.println(m==n);
	
	Integer x = 128;
	Integer y = 128;
	System.out.println(x==y);
	
引用类型
	类，数组，接口 

    数组也是特殊的类，也继承Object，实现相关方法


static关键字 
	static可以修饰属性，方法，代码块，内部类 
	
	变量
		非static变量，实例变量 
		static变量，类变量，共享
	
	类变量 	
		1.静态变量随着类的加载而加载，可以使用类.属性调用
		2.静态变量加载顺序要早与实例变量。
		3.类在内存中只能加载一次，类变量也只能加载一次，存在方法去的静态域中。
		
方法区 
	类的加载信息，静态域，常量池
	
	static方法
		1.静态方法随着类的加载而加载，可以使用类.方法调用
		2.静态方法可以调用静态方法和静态属性，不能调用非静态方法和非静态属性。
		3.静态方法内部不可以使用this和super关键字
		
单例模式 

/**
 * 单例模式，饿汉模式
 */
class Person{

    private Person(){}

    private static Person person = new Person();

    public static Person getInstance(){
        return person;
    }
}

/**
 * 单例模式，懒汉模式
 */
class Order{
    private Order(){}

    private static Order order = null;

    public static Order getInstance(){
        if (order == null){
            order = new Order();
        }
        return order;
    }
}

	单例模式优缺点：
		饿汉模式：
			优点：线程安全
			缺点：首先加载，过早加载，对象加载时间长
		懒汉模式：
			优点：晚加载，延迟加载
			缺点：线程不安全
			
代码块
	1.代码块的作用：用于初始化类或者对象
	2.代码块修饰只能static和非static修饰
	3.静态代码块随着类的加载而执行，且只能加载一次
	4.非静态代码块随着对象的创建而执行，并且每new一次创建一次
	5.多个静态代码块安装顺序执行，多个非静态代码块安装顺序执行，静态代码块和非静态代码库
	静态代码块比非静态代码块早执行
	6.静态代码块只能调用静态方法和静态属性
	7.非静态代码可以调用静态方法，静态属性，非静态方法，非静态属性
	
	
final关键字
	可以修饰类，方法，属性 
	
	修饰类 String 
	修饰方法 常量
	修饰属性 不能重写 Object.getClass()
	
	修饰变量
		显示初始化，代码块，构造器中，不能在方法中（因为在构造器之后的方法已经太晚了）
		
		方法内 
			形参 使用final修饰，表明此形参是个常量，方法体内只能使用，不能修改该值
			方法内表示常量
			
main方法
	1.main()程序的入口
	2.main()也可以是普通的静态方法
	3.main()也可以和控制台交换，类似Scanner
	
抽象类

	1.abstract可以修饰类和方法，不能修饰其他的
	2.abstract修饰的类不能创建对象(不能new)
	3.抽象类一定有构造器，抽象类的子类调用,最终调用Object的无参构造器，也就可以调用抽象类和超类的方法
	4.抽象类可以没有抽象方法，有抽象方法的类一定是抽象类(为什么？ 因为抽象方法只有声明没有方法体，如果是正常的类不能调用，所有只能是抽象的类)
	5.抽象类的子类必须都重写抽象类的抽象方法，子类才可以创建对象，否则子类也是抽象类不能创建对象
	6.abstract不能和final方法同时存在
	7.abstract方法不能修饰私有方法和静态方法(重写)
	
抽象类的匿名子类

	public class Test1 {

    public static void main(String[] args) {
        // 抽象类匿名子类
        Car car = new Car() {
            @Override
            void work() {
                System.out.println("匿名子类");
            }
        };
        method(car);

        //
        method(new Car() {
            @Override
            void work() {
                System.out.println("匿名对象的匿名子类");
            }
        });

    }

    public static void method(Car car){
        car.work();
        car.run();
    }

}

abstract class Car{
    private String name;
    private double price;
    public Car(){

    }
    public Car(String name,double price){
        this.name = name;
        this.price = price;
    }

    public void run(){
        System.out.println("车在跑！");
    }

    abstract void work();
}

class Bus extends Car{
    public Bus(){
        super();
    }

    @Override
    void work() {

    }
}

abstract class Jeep extends Car{
    public Jeep(){

    }
}


接口 
	interface
	1.接口和类是并列结构
	// jdk1.7及以前，只能定义全局常量和抽象方法
	2.可以定义全局常量(可以省略 public static final) 
		public static final int MAX_SPEED=10000;
		int MAX_SPEED = 1000;
	3.可以定义抽象方法(可以省略public abstract)
		public abstract void fly();
		void stop();
	// jdk1.8新增的功能，除了全局常量和抽象方法，还可以定义静态方法和默认方法	
		
		
		
	4.接口不能定义构造器，不能实例化接口
	5.使用类实现接口，实现功能
	  类实现接口的全部方法，才可以实例化，如果没有全部实现接口的方法，那么该类是抽象类
	
	interface Fly{
    void fly();
    void stop();
	}
	interface Fight{
		void fight();
		void war();
	}
	abstract class Plane implements Fly{

		@Override
		public void fly() {

		}
	}

	class Bomber implements Fly{

		@Override
		public void fly() {
			
		}

		@Override
		public void stop() {

		}
	}
	6.java类可以实现多个接口
	  格式：class AA extends BB implements CC,DD
	7.接口可以继承多个接口
	  格式：interface AA extends BB,CC
	  
	  类与类之间 重写,继承 extends
	  类与接口之间 实现 implements
	  接口与接口之间 继承，可以多继承 extends
	  
	8.接口的使用体现了多态性
	9.接口体现了一种规范
	
接口的匿名实现类	
	
	interface AA{
		void method();
	}
	interface BB{
		void method1();
	}
	interface CC extends AA,BB{
		void eat();
	}
	class DD implements CC{

		@Override
		public void method() {

		}

		@Override
		public void eat() {
			System.out.println("DD eat");
		}

		@Override
		public void method1() {

		}
	}

	class DDTest{
		public static void main(String[] args) {
			// 接口的匿名类实现
			DD dd = new DD();
			testMethod(dd);

			testMethod(new DD());
			
			CC cc = new CC() {
				@Override
				public void eat() {
					System.out.println("接口的非匿名实现类");
				}

				@Override
				public void method() {

				}

				@Override
				public void method1() {

				}
			};
			testMethod(cc);


			testMethod(new CC() {
				@Override
				public void eat() {
					System.out.println("接口的匿名实现类");
				}

				@Override
				public void method() {

				}

				@Override
				public void method1() {

				}
			});
		}
		public static void testMethod(CC cc){
			cc.eat();
		}
	}
	
经典的面试题
	public interface A{
		int x = 2;
	}
	public class B{
		int x = 1;
	}
	public class C extends B implements A{
		public void play(){
			System.out.println(x);
		}
	}
	// 这里到底报什么错误
	
	public interface A{
		void play();
	}
	public interface B{
		void play();
	}
	public interface C extends A,B{
		Ball ball = new Ball("PingPang");
	}
	
	public class Ball implements C{
		public static void main(String[] args){
			
		}
	
		public void play(){
			ball = new Ball("FootBall");
			System.out.println("-----);
		}
		
	}
	// 错误在哪里？
	

	jdk1.8的新特性
		1.除了全局常量和抽象方法，还可以定义静态方法和默认方法
			
			1.1静态方法只能是接口调用该方法，不能是实现类的对象调用，有点类似工具类
			1.2默认方法可以是实现类对象的调用
				如果实现类重写了接口的默认方法，调用时，仍然调用重写以后的方法
			1.3如果子类（或者实现类）继承的父类和实现类的接口声明了同名同参数的默认方法
				那么子类在没有重写该方法的情况下，默认调用父类的同名同参数方法。-类优先原则
			1.4如果实现类实现了多个接口，而这个多个接口声明了同名同参数的默认方法
			那么实现类没有重写此方法的接口，报错-接口冲突
			这就需要我们必须重写此方法
			1.5如何在子类(或者实现类)的的方法中调用父类或者接口中重写的方法
				A.super.method();				
				
内部类		
	成员内部类（静态和非静态），局部内部类(构造器，方法内，代码块)
	
	成员内部类：
		1.一方面作为外部类的成员
			调用外部类的结构
			可以使用static修饰
			可以使用4中不同的权限修饰符修饰
		2.另一方面作为类
			类内可以定义属性，方法，构造器，代码块等
			可以使用final修饰表示不能继承，反正可以继承
			可以使用abstract修饰表示抽象类
			
	注意：
		在局部内部类的方法中，如果要调用局部内部类所在声明的方法的局部变量
		需要声明final,1.7及以前需要声明为显式的final,1.8以后要隐式
		
		public void  method(){
			int age = 10;
			class XX{
				public void fly(){
					System.out.println(age);
				}
			}
		}
		
		内部类和外部类都要生成字节文件
		成员内部类生成字节文件是外部类$内部类.class 
		局部内部类生成字节文件是外部类$数字内部类.class 
		
异常 
	java.lang.Throwable
		java.lang.Error
		java.lang.Exception
			编译时异常(check)
				IoException
					FileNotFoundException
				classnotFoundException
			运行时异常(uncheck)
				NullPointerException
				ClassCastException
				ArrayIndexOfBoundsException
				NumberFormatException
	异常处理方式
		try-catch-finally  抛出异常自己处理
		throws 抛出了上级处理
				
	数据库连接，输入输出流，socket连接等,jvm不能自动释放，我们需要使用finnaly释放

	编译时异常常见try,catch,finally,如果不处理就不能编译
	运行时异常可以不用try,catch,finally,运行时异常很多无法确定
	
	如何选择使用try-catch-finally还是throws?
		1.如果父类中被重写的方法没有throws方式处理异常，则子类重写的
		方法也不能使用throws，意味着如果子类重写的方法异常必须使用try-catch-finally
		2.执行的方法a中，先手有调用了另外的几个方法，这几个方法是递进关系执行的。我们建议使用
		throws处理。而执行的方法a可以使用try-catch-finally
	
	手动异常,生成一个异常对象
		throw 
		throw new RuntimeException("手动异常！");
		
		1.继承RuntimeException或者Exception
		2.提供全局的序列化
		3.提供重载的构造器
	

		多线程
			程序：为了完成特定任务使用某种语言写的一组指令的集合。一段静态的代码。
			进程：正在运行的程序。有它自身的产生、存在和消亡的过程。进程作为资源分配的单位。
				系统在运行时会为每个进程分配不同的内存区域。
			线程：程序中的一条执行路径。
				一个进程同一时间并行执行多个线程，就是支持多线程
				线程作为调度和执行的单位，每个线程都有独立的运行栈和程序计算器
				一个进程中的多个线程可以共享相同的内存资源（方法区和堆）可以访问相同的变量和对象。实现线程之间的通信
				比较方便，但是可能存在安全隐患。
				
	一个java应该程序，至少存在一个main线程，一个垃圾回收线程，一个异常线程。
	
	并发和并行
		并行：多个CPU执行不同的任务
		并行：一个CPU同时执行不同的任务
		
	多线程的优点：
		提高应用程序的响应，增加用户的体验
		提高CPU的利用率
		改善程序结构
	为什么使用多线程：
		程序需要执行多个任务
		程序需要实现一些需要等待的任何时，比如用户输入，文件读写，网络操作等
		需要执行一些后台程序
		
	创建多线程
		Thread
			继承Thread实现run(),最后调用start()
			
			start()作用
				1.启动当前线程
				2.调用当前线程的run()
			run()方法 
				只调用该方法并不是启动当前线程
			一个线程可以多次调用start()吗 ?
			Thread t1 = new Thread();
			t1.start();
			t1.start();
			
		
	线程的方法
		start():启动当前线程并启动run()
		run():通常需要重写该方法，线程的主要业务写在此处
		currentThread():获取当前线程
		getName():当前线程名称
		setName():设置当前线程名称
		yield():释放CPU的执行权，有可能马上有获取执行权
		join():线程a调用线程b的join()方法，此线程进入阻塞状态，直到线程b执行完毕后，线程a才结束
			阻塞状态
		sleep(long millis):当前线程进入睡眠(毫秒)，进入阻塞状态
		stop():强制停止当前线程，不推荐
		isAlive():判断当前线程释放存活
		
	线程的优先级
		MAX_PRIORITY:10  最高 
		MIN_PRIORITY:1   最低
		NORM_PRIORITY:5  正常
		
		getPriority(): 获取线程优先值
		setPriority(int newPriority):设置当前线程优先级
		
		低优先级只是获取调用的概率低，并不一定是在高优先级线程之后才调用
		
	线程的创建方式
		extends Thread 
		implements Runnable
		
		比较 
			优先选择Runnable
			1.实现的方式没有类的单继承限制
			2.实现的方式更适合来处理多线程有共享数据的情况
			
			thread也实现了Runnable
			都需要重写run()
			
	线程分类
		守护线程（依赖用户线程，后台执行）gc回收
		用户线程
		
		
	线程的生命周期
		新建 new Thread()
		就绪 xx.start();yeild()
		运行 获取cpu执行权/sleep结束/join结束/notify/notifyAll/同步锁结束
		阻塞 sleep()/join()/synchronized()/await()
		死亡 执行完毕/stop()/异常
		各种状态直接的相互转换
	
	线程安全问题	
		同步代码块
			synchronized(监视器){
				xxx
			}
			例如：
			synchronized(obj){
				xxx
			}
			
			同步监视器(锁，任何对象都可以充当监视器)
				在继承Thread类中使用该类的.class或者static 对象变量
				在实现Runnable接口的类中可以使用Object或者this
				
				监视器要求多个线程共享一个
		同步方法
			也涉及到同步监视器，只不过不需要是显示的声明
			静态的同步方法，监视器是该类本身
				继续thread的类
			非静态的同步方法，该监视器是this
				实现Runnable接口的类
		
		死锁       
			不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。
			
			出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
			
			解决方法：
				专门的算法
				尽量避免同步资源的定义
				尽量避免嵌套同步
				
		Lock锁
			Reentranlock lock = new Reentranlock();
			
		synchronized和lock的区别
			相同：
				都解决线程安全问题
			不同：
				synchronized机制在执行同步代码（同步方法，同步代码块）以后，自动的释放同步监视器
				lock需要手动的执行同步（lock()），同步结束的时候也需要手动的执行释放同步监视器(unlock)
			  
		线程通信
			wait(),一旦执行该方法表示该线程处于阻塞状态，并且释放同步监视器
			notify()，一旦执行该方法，表示唤醒一个wait的线程，如果有多个线程则唤醒优先级高的
			notifyAll()，一旦执行该方法，表示唤醒全部wait的线程
			
			synchronized(this){
				this.notify();
				……
				……
				this.wait();
			}
			
			说明：
				wait(),notify(),notifyAll()只能使用在同步代码块或者同步方法中
				wait(),notify(),notifyAll()的调用者只能是同步代码块或者同步方法的同步监视器，否则出现
					illegalmonitorstateException异常
				wait(),notify(),notifyAll方法存在于Object类的方法
					
					
		sleep和wait的异同
			相同：
				都是线程阻塞
			不同： 
				sleep是Thread的方法，表示线程程阻塞但是不释放线程锁（同步监视器），可以使用在任何位置
				wait是Object的方法，表示线程阻塞释放线程锁，需要使用notify()或者notifyAll唤醒，只能使用在同步代码块或者同步方法中
				
		实现Callable接口
			相比run()方法有返回值
			方法可以抛出异常
			支持泛型的返回值
			
	public class CallableTest {

		public static void main(String[] args) {
			// 2. 创建实现Callable的类
			MyCallable myCallable = new MyCallable();

			// 3. FutureTask创建对象
			FutureTask futureTask = new FutureTask(myCallable);
			// 4.创建线程
			Thread thread = new Thread(futureTask);
			// 5.启动线程
			thread.start();

			try {
				// 6.获取调用Callable线程的的执行结果
				Object o = futureTask.get();
				System.out.println("获取的总和是："+o);
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
	}

	/**
	 * 1.实现Callable接口
	 */
	class MyCallable implements Callable{

		@Override
		public Object call() throws Exception {
			int sum = 0;
			for (int i = 1; i <= 100; i++) {
				if (i%2==0){
					System.out.println(i);
					sum += i;
				}
			}
			return sum;
		}
	}
			
	线程池
		好处：	
			1.提供响应速度
			2.降低资源消耗，线程使用完毕放回到线程池中
			3.便于线程管理
				corePoolSize:核心线程
				maximunumPoolsize:最多线程
				keepAliveTime:线程没有任务时候保持的最长时间后终止
			
		ExcutorServices service = Excutors.newFixedThreadPoole(10);	
		
	是否释放锁
		释放锁 
			1.同步方法或者同步代码块执行完毕，释放锁
			2.同步方法或者同步代码块中执行break,return 释放锁
			3.同步方法或者同步代码块中有未处理的异常或者错误，释放锁
			4.同步方法或者同步代码块中执行wait()，释放锁
		不释放锁
			1.线程执行sleep或者yield，不释放锁 
			2.线程被挂起,执行suspend方法
			
			
常用类的使用
	String,StringBulider,StringBuffer,Date,localDate,localTime,compare	
	
	字符串String
	public final class String
		implements java.io.Serializable, Comparable<String>, CharSequence {
		/** The value is used for character storage. */
		private final char value[];
		……
		}
		
	String 
		1.使用final修饰，表示不可被继承
		2.实现Serializable,Comparable,CharSequence接口
			Serializable表示序列化
			Comparable表示可以比较
		3.String内部定义 final char value[]用于存储字符串数组;
		4.String代表不可变的字符序列。
			1.重新赋值时候不可在原有的基础修改，只能重新开指定的内存空间赋值
				// 从内存中解析(栈，方法区字符串常量池)
				String s1 = "abc";
				s1 = "hello";
			
			2.在现在字符基础上连接操作也不可在原有基础上修改，只能重新指定新的内存空间赋值
				String s2 = "good";
				String s3 = s2+"fd";
				System.out.println(s2);
			3.当调用String的replace修改字符或者字符串也必须重新指定内存区域赋值
				String s3 = "good";
				String s4 = s3.replace("g","w");
				System.out.println(s3);
				System.out.println(s4);
		5.通过字面量的方式(区别new)给一个字符串赋值，此时字符串赋值在方法区中的字符串常量池中。
			String s1 = "abc";
			String s2 = "abc";
		6.常量池中是不会保持相同内容的字符串的
			堆，栈，方法区(包含字符串常量池)
		
	面试题
		String s = "hello";
		String s1 = new String("hello");
		s 和 s1 是否相同？
		
		String abc = new String("abc");在内存中创建了几个对象？
			一个是堆中的new结构，另一个是char[]对应的常量池中的数据："abc"
		
	常用赋值方式
		1,字面量赋值
			String s1 = "hello";
		2.new赋值
			String s2 = new String("hello");
	String的不同拼接
		1.两个常量池字符串拼接还是常量池字符串
		2.一个常量池字符串和一个变量拼接组成的在堆中
		3.堆中字符串.intern(),强制返回字符串常量
	//	
	public static void main(String[] args) {
        String s1 = "abc";
        String s2 = "def";
        String s3 = "abcdef";
        String s4 = "abc"+"def";
        String s5 = s1+"def";
        String s6 = "abc"+s2;
        String s7 = s1 +s2;
        String s8 = s7.intern();
		/// 非常重要的
		final String s9 = "abc";
		String s10 = s9+"def";
        System.out.println(s3==s4);
        System.out.println(s3==s5);
        System.out.println(s3==s6);
        System.out.println(s3==s7);
        System.out.println(s3==s8);
		System.out.println(s3==s10);
    }
		
		
	面试题 
		public static void main(String[] args) {
        String a = new String("good");
        char[] b = {'t','e','s','t'};
        StringTest test = new StringTest();
        test.change(a,b);
        System.out.println(a);
        System.out.println(b);
    }
    public void change(String a,char[] b){
        a = "test ok";
        b[0]= 'b';
    }
	
	String st = new String("abc123中国");
	// 采用默认编码
	byte[] s = st.getBytes();
	// 解码，特别需要注意编码和解码的时候字符集必须一致，否则乱码
	String ts = new String(s,"gbk");
	//
	Utf-8 汉字一个汉字3个字节，GBK一个汉字2个字节
	
	常见算法题目
	1.模拟一个trim方法，去除字符串两端的空格。
	2.将一个字符串进行反转。将字符串指定部分进行反转。比如"abcdefg"反转为"abfedcg"
	3.获取一个字符串在另一个字符串中出现的次数。
		比如：获取"ab"在"abkkcadkabkedfkabkskab"中出现的次数
	4.获取两个字符串中最大相同子串。比如：
		str1="abcwerthelloyuiodef";str2="cvhellobnm";
		提示：将短的那个串进行长度一次递减的子串与较长的串比较
	5.对字符串中字符进行自然顺序排序。
		提示：
			1) 字符串变成字符串数组
			2) 对数组排序，选择，冒泡，Arrays.sort();
			3) 将排序后的数组变成字符串	
	
	String,StringBuffer,StringBulider的区别
		String:不可变序列,底层用  char[] 存储
		StringBuffer:可以序列，线程安全,效率低,jdk1.0，底层用  char[] 存储
		StringBulider:可以序列，线程不安全，效率高，jdk1.5，底层用  char[] 存储
		
		源码分析：
			String String s = new String("abc");  实际上是 char[] t1 =new char[]{'a','b','c'};
			StringBuffer s1 = new StringBuffer();  实际上是  char[] t2 = new char[16];
			s1.append('a');  则是 t2[0]='a';
			s1.append('b');  则是 t2[1]='b';
			扩容问题：如果要添加的数据底层数组撑不下了，那就需要扩容底层的数组。
			默认情况下，扩容为原来的2倍+2，同时将原有数组的远程复制到新的数组中。
			
			防止因为扩容影响效率，建议使用 StringBuffer sb = new StringBuffer(50);
	
日期和时间
		System.currentTimeMills();  表示现在距离1970年1月1日0时0分0秒的时间戳(时间差)
		
		java.util.Date 
			java.sql.Date 
			方法	
				toString();
				getTime();  时间戳
			构造器 
				Date d = new Date();
				Date d1 = new Date(12323232431L);
			
			java.sql.date怎么实现java.util.date互转
				java.util.date --->java.sql.date 
					不能转换
					java.util.date.getTime() 
					java.sql.date t = new Date(java.util.date.getTime());
				java.sql.date--->java.util.date 直接转换
				
		SimpleDateFormat
			SimpleDateFormat sdf = new SimpleDateFormat();
			Date date = new Date();
			String time = sdf.format(date);
			sdf.parse();
			
			SimpleDateFormat sd = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				
	面试题 
		String str = null;
		StringBuffer sb = new StringBuffer();
		sb.append(str);
		System.out.println(sb.length);
		System.out.println(sb);
		
		StringBuffer sb1 = new StringBuffer(str);
		System.out.println(sb1);