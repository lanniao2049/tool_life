人机交换方式
	GUI(Graphical User Interface)
	CLI(Command Line Interface)
语言介绍
	第一代语言，二进制语言
	第二代语言，汇编语言
	第三代语言，高级语言(C，C++,Java等)
	
SUN(Stanford University Network)	

Java计算平台分类
	JSE(Java Standard Edition)
	JEE(Java Enterprise Edition)
	JME(Java Micro Edition)

Java的主要特点
	易学
	强制面向对象
	分布式(面向网络)
	健壮性(强类型机制，异常机制，垃圾自动回收机制)
	安全性
	中立性
	解释性
	性能略高
	原生支持多线程
	
Java的特征
	面向对象（继承，封装，多态）
	健壮性(和C,C++比较)
	跨平台
	
Java两大核心机制
	JVM(Java Virtual Machine)
		
	GC(Garbage Collection)
		程序自动垃圾回收，空闲时回收，手动调用System.gc()触发回收,但是无法可控

常用名称
	Jdk(Java development kit)>Jre(Java runtime environment)>Jvm(Java virtual machine)
		
	API(Application Programming Interface)	
Java 类中名称是否可以和文件名不一致？
	有public修饰的类名称必须和文件名一致，一个类中有且最多一个public修饰类，其他类可以有多个
	
	不用public修饰的类名和类名称可以不一致

变量类型
	基本数据变量
		byte,short,int,long,float,double,boolean,char
	引用变量
		class(字符串),接口,数组

	
变量位置
	成员变量
		实例变量(不用static修饰)
		类变量(static修饰)
	局部变量
		方法内
		代码块
		形参
	
	异同：
		生命周期不同
		成员变量不需要初始化，局部变量除了形参外需要初始化
		
		
变量注意事项	
	1.先定义，在使用
	2.有作用域
	3.同一个作用域中不能重复多个变量
	
	
基本类型区别
	类型	长度			表示范围
	byte 	1byte=8bit		-128-127
	short   2byte=16bit		-2^(16-1) - 2^(16-1)-1
	int 	4byte=32bit		-2^(32-1) - 2^(32-1)-1
	long 	8byte=64bit		-2^(64-1) - 2^(64-1)-1
	
	float	4byte=32bit
	double 	8byte=64bit
	
	char	2byte=16bit
	
	整型类型默认是int,使用long类型需要10L
	浮点类型默认是double,使用float需要使用51.0f/51.0F
	
	float表示的数值的范围比long还大，为什么？？
	
	
	char类型表示
		// 一个字符
		char a='9';
		// 转义字符
		char b='\n';
		// unicode
		char c =11;
		char e = '\u0123';
		// 一个字符
		char d = '中';
		char d1 =5;
		char d2 = '5';
		
		System.out.println(d1);
		
	boolean
		只能是false和true，不能是null
		
		JVM中true用1表示，false用0表示
		
编码
	ASCII
		一共规定128个字符
	Unicode
		
	
数据转换
	byte,short,char不能相互转换，只能转换为int在操作
	byte a1=125;
	short a2=45;
	char a3= 'a';
	
	a1+a2,
	a1+a3,
	a2+a3
	
	都是int接受
	//
	int d = 128;
    byte e = (byte) d;
	System.out.println(e);
	
	// 为什么可以？默认是int,提升到long
	long a1  = 123122;
	// 不可以的，因为默认int已经超出范围，必须加上后缀l/L
    long a2 = 2343243243243243;
    //	可以的
	long a3 = 2343243243243243l;
	
String	
	引用类型
	区分+到底是加法运算还是连接字符串操作关键看+前后两边是否是字符串

		int num1 = 19;
        char cha1 = 'a';
        String str1 = "hello";
        System.out.println(num1 + cha1 + str1);
        System.out.println(num1 + str1 + cha1);
        System.out.println(num1 + (cha1 + str1));
        System.out.println('a' + '\n' + '*');
        System.out.println('b' + '\n' + "good");
        System.out.println('b' + "\n" + "good");
        System.out.println("b" + "\n" + "good");	
		
进制之间的转换

	二进制
		0b01/0B01
	八进制
		01/02/07
	十六进制
		0x123/0X123
	
	二进制
		0 1 0 1 0 0 0 0
		首位是符合位 0 表示正数，1表示负数
		
		
	正数的原码，反码，补码一样，三码合一
	负数的原码，就是正数原码基础上符合位变为1 
	负数的反码，除符号位，其他全部取反
	负数的补码，反码+1
	
	计算机底层中都以补码的方式存储数据的
	
	
	10进制--》2进制
		除2取余的逆
		
		2 13 
		   6			1
			 3			0
			   1		1
			   0		1 
	二进制-->八进制 
		0000 0000 0000 0000
			三个一进
	二进制-->十六进制
			四个一进
			
	八进制转二进制
		0231
			010	011 001
	十六进制转二进制	
		0x234
			0010 0011 0100
			
	十进制与八进制，十六进制转换，可以通过中间二进制桥梁

运算符
	int num1 =12;
	int num2 = 5;
	double result1 = num1 / num2;
	double result2 = num1 / num2 +0.0;
	double result3 = num1 / (num2+0.0);
	double result4 = (double)num1/num2;
	double result5 = (double)(num1/num2);
	
	// 取模结果与被取模的符号位一致

        int num1 = 12;
        int num2 = 5;

        System.out.println("num1%num2 "+num1%num2);

        int m1 = -12;
        int n1 = 5;
        System.out.println("m1%n1 "+m1%n1);

        int m2 = 12;
        int n2 = -5;
        System.out.println("m2%n2 "+m2%n2);

        int m3 = -12;
        int n3 = -5;
        System.out.println("m3%n3 "+m3%n3);
		
	// 自增计算
        short a1 = 10;
        // a1怎么实现+1的操作
//        a1 = a1+1;
//        a1+1;
        a1 = (short)( a1+1);
        // 使用自增运算，数据类型在原来的基础上不会改变(二进制的基础上+1)
        a1++;
        System.out.println(a1);

        byte b1 = 127;
        b1++;
        System.out.println(b1);
		
		byte c1 = -128;
        c1--;
        System.out.println(c1);
		
		// 一个三位数，分别输出百位数，十位数，个位数
        int number = 823;
        int bai = number/100;
        int shi = number%100/10;
        int ge = number%10;
        System.out.println("百位数："+bai+",十位数："+shi+",个数数："+ge);
		
		
	// 赋值运算
        short s1 = 5;
        // n+=2 可以理解为 n = n+2;但是和真正的n+2还是不一样的
//        s1 = s1+2;  编译失败
        // 使用下面的不改变数据的基本类型
        s1+=2;
		
		// 思考题1
        short s1 = 5;
        /*
        s1 = s1+2;
        s1+2;
        两者有什么区别？
        */
        // 思考题2
        int a = 1;
        a*=0.1;
        System.out.println(a);
        a++;
        System.out.println(a);
        // 思考题3
        int m =2;
        int n =3;
        n*=m++;
        System.out.println("n="+n+",m="+m);
        // 思考题4
        int n1 = 10;
        n1+=(n1++)+(++n1);
        System.out.println(n1);
		
		  // 经典自增面试题
    public static void  test1(){
        boolean x = true;
        boolean y = false;
        short z =42;
//        if (y==true)
        if ((z++==42)&(y=true))z++;
        if (x=false||(++z==45))z++;
        System.out.println(z);
    }
	
位运算符
	<< 左移
		空位补0，高位丢弃
	>> 右移
		高位为0时，右移后，高位补0
		高位为1时，右移后，高位补1
	>>> 无符号右移
		被移位二级制无论是0或者1，空缺位都是0
	&  二进制与操作，都为1则为1，否则为0
	|  二级制或操作，只要有一个1则为1，全部为0才为0
	^  二级制异或操作，不同才为1，相同则为0
	
	/**
     * 经典a,b交换
     */
    public static void test2(){
        int a =10;
        int b =20;
        System.out.println("a = "+a+",b="+b);

        // 推荐使用该方法，使用与任何数据类型
//        int temp = a;
//        a = b;
//        b = temp;
//        System.out.println("a = "+a+",b="+b);

        // 下面的方法
        // 优点：不适用临时变量，缺点：1.有可能超出数据限制，2，仅能使用与数字类型，不能使用String等的交换
//        a = a+b;
//        b = a-b;
//        a = a -b;
//        System.out.println("a = "+a+",b="+b);

        // 使用^运算 ，仅使用与整数类型
        a = a^b;
        b = a^b;
        a = a^b;
        System.out.println("a = "+a+",b="+b);	
		
		
数组 
	1.数组存放同样类型的数据(可以是基本类型的也可以是引用类型的数据)
	2.数组存放数据有一定的顺序
	3.数组在内存中的空间是连续的
	4.数组空间大小一旦确定不可更改
	
	
	public static void test4(){
        // 动态初始化，堆，栈，内存分布情况
        int[] a = new int[5];
        // 静态初始化
        int[] a1 = new int[]{2, 3, 4, 5};
        // 怎么理解该情况
        int[] a2 = {};
        System.out.println("a2 " + a2);
        // 类型推断
        int[] a3 = {1,2,5,};
        int[] a4;
        a4 = new int[4];
        // 下面先声明，后初始化为什么不能使用类型推断
//        int[] a5;
//        a5 = {1,2,3};
    }
	
二维数组
	
	
	public static void  test1(){
        // 二维数组
        int[][] a1 = new int[5][4];
        int[][] a2 = {{1,2,3},{1,2},{},{5}};
        int[][] a3;
        a3 = new int[12][];
//        int[][] a4;
//        a4 = {{1,2},{2,3},{4,5}}

        String[][] st1 = new String[5][];
        System.out.println(st1);
        System.out.println(st1[0]);
        System.out.println(a3[1]);
        System.out.println(a2[1]);
		System.out.println(a2[0].length);
    }

数组 
	二维数组
	// 如何理解y的赋值
	int[]x,y[];
	
	public static void test2(){
        // 特别要注意x是一维数组，y是二位数组
        int[]x,y[],z;
        x = new int[]{1, 2, 3, 4};
        y = new int[][]{{1, 2, 3,}, {2, 3}};
    }

数组的算法

	/**
     * 杨辉三角，首尾元素都为1，其他元素满足y[i][j]=y[i-1][y-1]+y[i-1][y]
     */
    public static void test4(){
        // 1.杨辉三角初始化
        int[][] yangHui = new int[10][];
//        yangHui[0] = new int[1];
//        yangHui[1] = new int[2];
//        yangHui[2] = new int[3];

        // 2.赋值
        for (int i = 0; i < yangHui.length; i++) {
            // 2.1初始化数组
            yangHui[i] = new int[i+1];
            // 2.2首尾元素赋值
            yangHui[i][0] = 1;
            yangHui[i][i] = 1;
            
            // 2.3其他数据元素赋值
            if (i>1){
                for (int j = 1; j < yangHui[i].length-1; j++) {
                    yangHui[i][j] = yangHui[i-1][j-1] + yangHui[i-1][j];
                }
            }
        }
        // 3.遍历所有元素
        for (int i = 0; i < yangHui.length; i++) {
            for (int j = 0; j < yangHui[i].length; j++) {
                System.out.print(yangHui[i][j]+"\t");
            }
            System.out.println();
        }
    }
	
	/**
     * 一个为10的数组，元素是两位数的正整数随机数，求该数组的最大值，最小值，和以及平均值
     * [10,99] ，计算公式(int)(Math.random()*(99-10+1)+10)
     */
    public static void test5(){
        int[] numbers = new int[10];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = (int) (Math.random() * (99 - 10 + 1) + 10);
            System.out.print(numbers[i]+"\t");
        }
        int maxValue = numbers[0];
        for (int i = 0; i < numbers.length; i++) {
            if (maxValue<numbers[i]){
                maxValue = numbers[i];
            }
        }
        System.out.println();
        System.out.println("最大值是："+maxValue);
        int minValue = numbers[0];
        for (int i = 0; i < numbers.length; i++) {
            if (minValue>numbers[i]){
                minValue = numbers[i];
            }
        }
        System.out.println("最小值是："+minValue);

        int sum = 0;
        for (int i = 0; i < numbers.length; i++) {
            sum += numbers[i];
        }
        System.out.println("和是："+sum);

        int avg = sum/numbers.length;
        System.out.println("平均值是："+avg);
    }
	
	/**
     * 数组之间相互赋值，复制的区别
     */
    public static void test6(){
        int[] arry1 = new int[]{1,9,8,23,84,43,29};
        for (int i = 0; i < arry1.length; i++) {
            System.out.print(arry1[i]+"\t");
        }
        System.out.println();
        int[] arry2 = arry1;
//        // 修改数组arr2中偶数索引为索引值，例如 i[0]=0,i[2]=2
//        for (int i = 0; i < arry2.length; i++) {
//            if (i%2==0){
//                arry2[i] = i;
//            }
//        }

        // 复制
        int[] arry3 = new int[arry1.length];
        for (int i = 0; i < arry3.length; i++) {
            arry3[i] = arry1[i];
        }

        for (int i = 0; i < arry1.length; i++) {
            System.out.print(arry1[i]+"\t");
        }
    }
	
	/**
     * 数组元素反转
     */
    public static void test7(){
        String[] str1 = new String[] {"JJ","DD","BB","AA","LL","GG","WW","TT","NN","UU","II","RR"};
        // 第一种方案 temp临时变量
//        for (int i = 0; i < str1.length/2; i++) {
//            String temp = str1[i];
//            str1[i] = str1[str1.length-1-i];
//            str1[str1.length-1-i] = temp;
//        }
//        for (int i = 0; i < str1.length; i++) {
//            System.out.print(str1[i]+"\t");
//        }
//        System.out.println();

        // 第二种方案 从两边向中间比较
        for (int i = 0,j= str1.length-1;i<j;i++,j--){
            String temp = str1[i];
            str1[i] = str1[j];
            str1[j] = temp;
        }

        for (int i = 0; i < str1.length; i++) {
            System.out.print(str1[i]+"\t");
        }
        System.out.println();
    }
	
	 /**
     * 数组查找方法，线性查找，二分法查找
     */
    public static void test8(){
        String[] str = new String[]{"JJ","DD","BB","AA","LL","GG","WW","TT","NN","UU","II","RR"};

        // 线性查找
        String dest = "GG";
        boolean isFlag = true;
        for (int i = 0; i < str.length; i++) {
            if (dest.equals(str[i])){
                System.out.println("查找到指定元素的坐标是 " + i);
                isFlag = false;
                break;
            }
        }
        if (isFlag) {
            System.out.println("没有查找到指定的元素");
        }
    }


	/**
     * 二分法查找，注意使用该二分法必须按照一定的顺序排序后才可以使用
     */
    public static void test9(){
        int[] num = {-89,-56,-45,-38,-21,-9,12,24,36,48,59,66,78,83,91,99};
        int dest = 36;
        // 首位索引
        int head = 0;
        // 尾位索引
        int end = num.length - 1;
        boolean isFlag = true;
        while (head <= end){
            int middle = (head + end)/2;
            if (dest == num[middle]){
                System.out.println("找到目标数据元素，位置是 " + middle);
                isFlag = false;
                break;
            } else if (num[middle]>dest){
                end = middle -1;
            } else {
                // num[middle]<dest
                head = middle+1;
            }
        }
        if (isFlag) {
            System.out.println("没有查找到该目标元素！");
        }
    }
	
	
	
	// 6个正整数 从随机1-30选取，各个元素都不相同
	  
	 
	// 回形针数组样例
	
	

算法优劣的标注
	时间复杂度
	空间复杂度
	稳定性

	/**
     * 经典算法：冒泡排序，相邻的元素依次比较，前面的数据比后面的数据大则交换，依次运算
     */
    public static void test10(){
        int[] numbers = {-12,-23,-46,9,87,23,-13,-34,-7,43,12,89,99};
        // 大伦次数
        for (int i = 0; i < numbers.length-1; i++) {
            // 每次大伦次下的小对比次数
            for (int j = 0;j< numbers.length-1-i;j++){
                // 判断相邻两个元素的大小关系，前面元素大于后面的元素则交换
                if (numbers[j]>numbers[j+1]){
                    int tmp = numbers[j];
                    numbers[j] = numbers[j+1];
                    numbers[j+1] = tmp;
                }
            }
        }
        // 遍历所有数据
        for (int i = 0; i < numbers.length; i++) {
            System.out.print(numbers[i]+"\t");
        }
    }
	
各个算法之间的对比
	时间复杂度
	空间复杂度
	稳定性
	
	
	最常使用的算法是冒泡排序，快速排序，堆排序等
	
	
经典算法必会
	十种经典算法，杨辉三角，回形针数组
		冒泡排序，选择排序，快速排序，堆排序，插入排序，归并排序等
	
数组常见异常
	ArrayIndexOfBoundsException
	NullPointerException
	

java对象
	类与对象
		类是对象的抽象，对象是类的具体化。
		
	特点：
		多态，继承，封装
		
	JVM内存分布
		堆，栈，方法区，本地方法栈
	

成员变量和局部变量的区别

	相同点：
		1.都是先声明后使用
		2.都有作用域(生命周期)
		3.格式都一样 ，数据类型 变量名=变量值
	不同点：
		1.位置不同
			成员变量位于类下
			局部变量位于方法内，方法形参，构造方法内，构造方法形参，代码块中
		2.默认值不同
			成员变量有默认初始化值
				byte,short,int,long,float,double,char,boolean使用各自的默认初始值
				String,对象，类其他的默认初始化值为null
			局部变量没有初始化值，使用前必须赋值
				特殊情况：方法形参，构造器形参不需要赋值，在调用该办法的时候赋值
		3.权限修饰符不同
			成员变量可以使用private,public,缺省,protect修饰
			局部变量不可以使用权限修饰符（仅使用缺省）
		4.内存位置不同
			成员变量(非static)位于内存中的堆中
			局部变量位于内存中的栈中
		5.生命周期不同	
			成员变量生命周期和对象生命周期一致
			局部变量生命周期在方法，构造器，代码块结束消亡


方法
	权限修饰符 返回值 方法名(){
		方法体
	}

面向对象
	类的设计：属性，方法，构造器，内部类，代码块 
	面向对象的特征：封装，继承，多态 

如何理解面向对象的编程？

栈，堆是在编译是还是在运行是？
	源代码.java文件编译生成.class文件，字节文件在JVM运行时加载Load分配生成内存，即响应的栈，堆等 



如何理解万事万物皆对象
	1.在java语言范畴内，我们都将功能和结构封装到类中，通过类的实例化，调用对象的具体功能。
		Scanner,String,
		文件对象：File
		网络对象：URl
	2.在java与前端html,json,后端数据库等数据交互时，都体现类、对象。
	
匿名对象
	1.该对象没有显式命名变量名，即为匿名变量
	2.匿名对象只可调用一次
	3.使用场景 xxx.method(new Xxxx());
	

方法的重载
	
	两同一不同：
		两同：同一个类；同样的方法名称
		一不同：参数列表不同（参数类型不同，参数个数不同，参数顺序不同）
		
	判断重载依据：
		根据定义确定，与方法的修饰符，方法的返回值，形参变量名和方法体无关
		
	
	如何确定一个方法
		方法名+参数列表 
		
		如果因为方法修饰符和方法返回值不同构成重载那具体到底调用哪个方法
		
	
	可变形参
	
	
    private void method(String name){

    }

    /**
     * 1.可变个数形参方法和数组方法相同的方法不可同时存着，不构成重载
     * 2.可变个数形参参数必须位于最后
     * 3.在方法中可变形参个数最多只能有一个
     * 4.方法可变个数形参可以和方法名相同参数列表不同的共存，重载
     * 5.方法可变个数形参，可以传0个到N个同样的参数
     * @param strings
     */
    public void method(String ... strings){

    }

//    public void method(String[] args){
//
//    }

    public void method(int age,String ... strings){

    }
    // 写法错误
//    public void method(String ... strings,double salary){
//
//    }

字符串常量池
	
封装性
	体现
		1.属性私有化，获取get和set属性
			public void setAge(int age){
				this.age = age;
			}
			public int getAge(){
				return age;
			}
		2.方法私有化
		3.构造器私有化（单例模式）
		4.缺省修饰的类，包外不能调用

权限修饰符
	private 缺省 protected public

	
	各个修饰符的权限
	private  仅在同一个类中
	缺省  在同一个类中，同一个包中
	protected 同一个类中，同一个包，不同的包中
	public 同一个类中，同一个包，不同的包中，同一个工程
	
	各个修饰符可以修饰类，属性，方法，构造器，内部类

	类的修饰符只能是public 和缺省不能使用private

构造器
	
	构造器的重载	
	
属性赋值的先后顺序
	默认初始化
	显示初始化
	构造器赋值
	set设置
	
this关键字的使用
	
	this是当前对象，可以修饰属性，方法 
	
	this可以修饰构造器
	
	构造器下最多只能有一个this调用其他的构造器，并且调用this的构造器必须位于方式的首行
	
继承 
	extends
	好处：
		1.减少冗余，提供代码复用性
		2.便于扩展
		3.多态性
		
	子类继承父类，一定继承父类的所以属性和方法
		
	父类的私有属性，私有方法，子类继承了吗？
		
		继承，子类由于权限修饰的问题不能调用
		
	规定：
		1.一个类可以有多个子类继承
		2.一个类有且最多只有一个父类，单继承
		3.子父类是相对
		4.子类获取父类和所有间接父类的方法和属性
		
Object类
	1.所有的类都直接或者间接的继承java.lang.Object类
	2.所有的类都继承java.lang.Object类的方法和属性
		

重写(overide)
	子类继承父类，覆盖父类的方法（方法名相同和参数列表相同）
	
	规定：	
		1.重写的子类和父类方法名称和参数列表相同
		2.权限修饰重写的子类不小于父类的权限修饰符
			注意：如果父类权限是private则不能重写
		3.返回值 
			如果父类是void,则子类必须也是void
			如果父类是基本类型，则子类必须也是相同的基本类型
			如果父类是A类型，则子类必须是对象或者其子类，比如父类是Object,子类是String
		4.重写的子类的异常不能大于父类的异常，如父类异常是exception,子类可以是RuntimeException

				
		重写必须是子类和父类都是非static修饰，static修饰的方法是类方法不能被重写，同样的方法父类用static，子类必须也用static
		
super
	子类和父类之间的关系
	
	super可以调用父类属性，方法，构造器 
		super.age 
		super.eat(name);
		super(age,name);
	子类的构造器调用父类的构造器使用super必须位于首行
	在构造器中this(形参)和super(形参)只能二选一
	在构造器没有显式的调用super，默认的调用父类无参构造器
	

子类对象实例化的过程
	1.从执行结果上看：
		子类继承父类，就可以获取父类声明的属性和方法
		创建子类对象，在堆空间就可以获取父类的属性
	2.从执行过程上看：
		当我们创建子类对象，一定会直接或者间接的调用父类的构造器，直到调用到
		java.lang.Object类构造器结束，正因为加载了所有的父类构造器，所有在内存空间上
		可以看到的父类的结构，子类可以考虑调用。
		
	特别说明：
		子类创建对象，到底创建了几个对象？
		子类创建对象，虽然调用多个父类构造器，但是创建对象只new 一个(new 关键字)

多态		
	父类的引用指向子类的对象
	Person p = new Man();
	p.eat();
	编译期只能调用父类的方法，但是在运行期调用的是子类的方法。（虚拟方法调用）
	编译看左边，运行看右边
		
	对象的多态，不适用声明的属性，只使用方法，都是编译看左边
	Person p = new Woman();
	p.age = 1; // 该属性指的是Person的属性
	
	
	重载在编译期已经可以确定调用那个方法了是早绑定，静态绑定，不是多态
	
	重写只有在解析器解释的时候才能确定调用那个，是晚绑定，动态绑定，是多态
	
多态中向下类型转换
	父类型不能调用子类特有的属性和方法，编译期看左边父类
	有了对象的多态后，内存中实际上加载了子类特有的属性和方法，但是变量名声明为父类，
	编译期，只能调用父类的属性和方法。子类特有的属性和方法不能调用。
	Person p = new Man();

	// 以下编译错误
	p.isSmoking = true;
	p.playGame();
	
	//那么如何调用子类特用的属性和方法？
	//
	Man man = (Man)p;
		
instance of的使用
	
	为了避免ClassCastException，使用instance of 
	a instance of A，如果true说明a是A类型
	
	经典案例 
	
	class Base{
		int count = 10;
		public void display(){
			System.out.println(this.count);
		}
	}
	class Sub extends Base{
		int count = 20;
		public void display(){
			System.out.println(this.count);
		}
	}
	
	public class SubTest{
		public void mian(String []args){
			Sub sub = new Sub();
			System.out.println(sub.count);
			sub.display();
			Base base = sub;
			System.out.println(base==sub);
			System.out.println(base.count);
			System.out.println(base.count);
		}
	}
	
	多态经典案例
	
	class Base{
		public void add(int a,int... arr){
			System.out.println("base");
		}
	}
	class Sub extends Base{
		public void add(int a,int[] arr){
			System.out.println("sub1");
		}
		
		public void add(int a,int b, int c){
			System.out.println("sub2");
		}
	}
	
	public class SubTest1{
		public static void main(String[] args){
			Base b = new 
			();
			b.add(1,2,3);
			
			Sub s = (Sub)b;
			s.add(1,2,3);
		}
	}
	
==的使用  运算符
	1、可以使用基本类型和引用类型
	2、使用基本类型比较的是存储的值是否相等（可以是不同的基本类型），引用类型比较的是存储的地址是否相等

equals的使用
	1.是方法，不能使用了基本类型，只能使用引用类型
	2.Object类中的equals实际上使用的==比较的使用引用地址是否相同，String,Date,File、包装类等
	中的equals比较的是实体内容是否相同
	3.对于自定类中的equls方法，通常我们比较的是实体内容是否相同，这样就需要我们重写
	Object类的equals方法，重写的原则就是比较实体内容是否相同
	
	
	重写的原则：
		1.对称性  a.equals(b)和b.equals(a)
		2.自反性  a.equals(a)
		3.传递性  a.equals(b),b.equals(c)则 a.equals(c)相同 
		4.任何对象.equals(null)一定是false，前提条件对象不能为null
		5.两个对象类型不一致，一定是false 
	
Object类的使用 
	
    toString()方法
		1.输出对象实际调用的是Object类的toString()
		2.Object类的toString实际输出的是
		public String toString() {
			return getClass().getName() + "@" + Integer.toHexString(hashCode());
		}
		3.String,Date,包装类等的toString()实际重写了Object的toString()方法
		4.自定义类的toString()输出，需要重写Object的toString()方法，返回的对象的实体内容
		
		特别注意：
		String a = "ssdfdf";
		a = null;
		System.out.println(a);
		System.out.println(a.toString());
		
	
包装类的使用 

	主要是基本类型有类的特征
	
	Boolean flag = new Boolean("true");
	Boolean flag1 = new Boolean(true);
	Boolean flag2 = new Boolean("True");
	Boolean flag3 = new Boolean("trueadf");
	
	经典的面试
	
	Object o1 = true ? new Integer(1):new Double(2.0);
	System.out.println(o1);
	
	Object2 o2;
	if(true)
		o2 = new Integer(1);
	else
		o2 = new Double(2.0);
	System.out.println(o2);	
	
	
	Integer i = new Integer(1);
	Integer j = new Integer(1);
	System.out.println(i==j);
	
	Integer m = 1;
	Integer n = 1;
	System.out.println(m==n);
	
	Integer x = 128;
	Integer y = 128;
	System.out.println(x==y);
	
引用类型
	类，数组，接口 

    数组也是特殊的类，也继承Object，实现相关方法


static关键字 
	static可以修饰属性，方法，代码块，内部类 
	
	变量
		非static变量，实例变量 
		static变量，类变量，共享
	
	类变量 	
		1.静态变量随着类的加载而加载，可以使用类.属性调用
		2.静态变量加载顺序要早与实例变量。
		3.类在内存中只能加载一次，类变量也只能加载一次，存在方法去的静态域中。
		
方法区 
	类的加载信息，静态域，常量池
	
	static方法
		1.静态方法随着类的加载而加载，可以使用类.方法调用
		2.静态方法可以调用静态方法和静态属性，不能调用非静态方法和非静态属性。
		3.静态方法内部不可以使用this和super关键字
		
单例模式 

/**
 * 单例模式，饿汉模式
 */
class Person{

    private Person(){}

    private static Person person = new Person();

    public static Person getInstance(){
        return person;
    }
}

/**
 * 单例模式，懒汉模式
 */
class Order{
    private Order(){}

    private static Order order = null;

    public static Order getInstance(){
        if (order == null){
            order = new Order();
        }
        return order;
    }
}

	单例模式优缺点：
		饿汉模式：
			优点：线程安全
			缺点：首先加载，过早加载
		懒汉模式：
			优点：晚加载，用的时候才加载
			缺点：线程不安全
			
代码块
	1.代码块的作用：用于初始化类或者对象
	2.代码块修饰只能static和非static修饰
	3.静态代码块随着类的加载而执行，且只能加载一次
	4.非静态代码块随着对象的创建而执行，并且每new一次创建一次
	5.多个静态代码块安装顺序执行，多个非静态代码块安装顺序执行，静态代码块和非静态代码库
	静态代码块比非静态代码块早执行
	6.静态代码块只能调用静态方法和静态属性
	7.非静态代码可以调用静态方法，静态属性，非静态方法，非静态属性
	
	
final关键字
	可以修饰类，方法，属性 
	
	修饰类 String 
	修饰方法 常量
	修饰属性 不能重写 Object.getClass()
	
	修饰变量
		显示初始化，代码块，构造器中，不能在方法中（因为在构造器之后的方法已经太晚了）
		
		方法内 
			形参 使用final修饰，表明此形参是个常量，方法体内只能使用，不能修改该值
			方法内表示常量