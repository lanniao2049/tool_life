人机交换方式
	GUI(Graphical User Interface)
	CLI(Command Line Interface)
语言介绍
	第一代语言，二进制语言
	第二代语言，汇编语言
	第三代语言，高级语言(C，C++,Java等)
	
SUN(Stanford University Network)	

Java计算平台分类
	JSE(Java Standard Edition)
	JEE(Java Enterprise Edition)
	JME(Java Micro Edition)

Java的主要特点
	易学
	强制面向对象
	分布式(面向网络)
	健壮性(强类型机制，异常机制，垃圾自动回收机制)
	安全性
	中立性
	解释性
	性能略高
	原生支持多线程
	
Java的特征
	面向对象（继承，封装，多态）
	健壮性(和C,C++比较)
	跨平台
	
Java两大核心机制
	JVM(Java Virtual Machine)
		
	GC(Garbage Collection)
		程序自动垃圾回收，空闲时回收，手动调用System.gc()触发回收,但是无法可控

常用名称
	Jdk(Java development kit)>Jre(Java runtime environment)>Jvm(Java virtual machine)
		
	API(Application Programming Interface)	
Java 类中名称是否可以和文件名不一致？
	有public修饰的类名称必须和文件名一致，一个类中有且最多一个public修饰类，其他类可以有多个
	
	不用public修饰的类名和类名称可以不一致

变量类型
	基本数据变量
		byte,short,int,long,float,double,boolean,char
	引用变量
		class(字符串),接口,数组

	
变量位置
	成员变量
		实例变量(不用static修饰)
		类变量(static修饰)
	局部变量
		方法内
		代码块
		形参
	
	异同：
		生命周期不同
		成员变量不需要初始化，局部变量除了形参外需要初始化
		
		
变量注意事项	
	1.先定义，在使用
	2.有作用域
	3.同一个作用域中不能重复多个变量
	
	
基本类型区别
	类型	长度			表示范围
	byte 	1byte=8bit		-128-127
	short   2byte=16bit		-2^(16-1) - 2^(16-1)-1
	int 	4byte=32bit		-2^(32-1) - 2^(32-1)-1
	long 	8byte=64bit		-2^(64-1) - 2^(64-1)-1
	
	float	4byte=32bit
	double 	8byte=64bit
	
	char	2byte=16bit
	
	整型类型默认是int,使用long类型需要10L
	浮点类型默认是double,使用float需要使用51.0f/51.0F
	
	float表示的数值的范围比long还大，为什么？？
	
	
	char类型表示
		// 一个字符
		char a='9';
		// 转义字符
		char b='\n';
		// unicode
		char c =11;
		char e = '\u0123';
		// 一个字符
		char d = '中';
		char d1 =5;
		char d2 = '5';
		
		System.out.println(d1);
		
	boolean
		只能是false和true，不能是null
		
		JVM中true用1表示，false用0表示
		
编码
	ASCII
		一共规定128个字符
	Unicode
		
	
数据转换
	byte,short,char不能相互转换，只能转换为int在操作
	byte a1=125;
	short a2=45;
	char a3= 'a';
	
	a1+a2,
	a1+a3,
	a2+a3
	
	都是int接受
	//
	int d = 128;
    byte e = (byte) d;
	System.out.println(e);
	
	// 为什么可以？默认是int,提升到long
	long a1  = 123122;
	// 不可以的，因为默认int已经超出范围，必须加上后缀l/L
    long a2 = 2343243243243243;
    //	可以的
	long a3 = 2343243243243243l;
	
String	
	引用类型
	区分+到底是加法运算还是连接字符串操作关键看+前后两边是否是字符串

		int num1 = 19;
        char cha1 = 'a';
        String str1 = "hello";
        System.out.println(num1 + cha1 + str1);
        System.out.println(num1 + str1 + cha1);
        System.out.println(num1 + (cha1 + str1));
        System.out.println('a' + '\n' + '*');
        System.out.println('b' + '\n' + "good");
        System.out.println('b' + "\n" + "good");
        System.out.println("b" + "\n" + "good");	
		
进制之间的转换

	二进制
		0b01/0B01
	八进制
		01/02/07
	十六进制
		0x123/0X123
	
	二进制
		0 1 0 1 0 0 0 0
		首位是符合位 0 表示正数，1表示负数
		
		
	正数的原码，反码，补码一样，三码合一
	负数的原码，就是正数原码基础上符合位变为1 
	负数的反码，除符号位，其他全部取反
	负数的补码，反码+1
	
	计算机底层中都以补码的方式存储数据的
	
	
	10进制--》2进制
		除2取余的逆
		
		2 13 
		   6			1
			 3			0
			   1		1
			   0		1 
	二进制-->八进制 
		0000 0000 0000 0000
			三个一进
	二进制-->十六进制
			四个一进
			
	八进制转二进制
		0231
			010	011 001
	十六进制转二进制	
		0x234
			0010 0011 0100
			
	十进制与八进制，十六进制转换，可以通过中间二进制桥梁

运算符
	int num1 =12;
	int num2 = 5;
	double result1 = num1 / num2;
	double result2 = num1 / num2 +0.0;
	double result3 = num1 / (num2+0.0);
	double result4 = (double)num1/num2;
	double result5 = (double)(num1/num2);
	
	// 取模结果与被取模的符号位一致

        int num1 = 12;
        int num2 = 5;

        System.out.println("num1%num2 "+num1%num2);

        int m1 = -12;
        int n1 = 5;
        System.out.println("m1%n1 "+m1%n1);

        int m2 = 12;
        int n2 = -5;
        System.out.println("m2%n2 "+m2%n2);

        int m3 = -12;
        int n3 = -5;
        System.out.println("m3%n3 "+m3%n3);
		
	// 自增计算
        short a1 = 10;
        // a1怎么实现+1的操作
//        a1 = a1+1;
//        a1+1;
        a1 = (short)( a1+1);
        // 使用自增运算，数据类型在原来的基础上不会改变(二进制的基础上+1)
        a1++;
        System.out.println(a1);

        byte b1 = 127;
        b1++;
        System.out.println(b1);
		
		byte c1 = -128;
        c1--;
        System.out.println(c1);
		
		// 一个三位数，分别输出百位数，十位数，个位数
        int number = 823;
        int bai = number/100;
        int shi = number%100/10;
        int ge = number%10;
        System.out.println("百位数："+bai+",十位数："+shi+",个数数："+ge);
		
		
	// 赋值运算
        short s1 = 5;
        // n+=2 可以理解为 n = n+2;但是和真正的n+2还是不一样的
//        s1 = s1+2;  编译失败
        // 使用下面的不改变数据的基本类型
        s1+=2;
		
		// 思考题1
        short s1 = 5;
        /*
        s1 = s1+2;
        s1+2;
        两者有什么区别？
        */
        // 思考题2
        int a = 1;
        a*=0.1;
        System.out.println(a);
        a++;
        System.out.println(a);
        // 思考题3
        int m =2;
        int n =3;
        n*=m++;
        System.out.println("n="+n+",m="+m);
        // 思考题4
        int n1 = 10;
        n1+=(n1++)+(++n1);
        System.out.println(n1);
		
		  // 经典自增面试题
    public static void  test1(){
        boolean x = true;
        boolean y = false;
        short z =42;
//        if (y==true)
        if ((z++==42)&(y=true))z++;
        if (x=false||(++z==45))z++;
        System.out.println(z);
    }
	
位运算符
	<< 左移
		空位补0，高位丢弃
	>> 右移
		高位为0时，右移后，高位补0
		高位为1时，右移后，高位补1
	>>> 无符号右移
		被移位二级制无论是0或者1，空缺位都是0
	&  二进制与操作，都为1则为1，否则为0
	|  二级制或操作，只要有一个1则为1，全部为0才为0
	^  二级制异或操作，不同才为1，相同则为0
	
	/**
     * 经典a,b交换
     */
    public static void test2(){
        int a =10;
        int b =20;
        System.out.println("a = "+a+",b="+b);

        // 推荐使用该方法，使用与任何数据类型
//        int temp = a;
//        a = b;
//        b = temp;
//        System.out.println("a = "+a+",b="+b);

        // 下面的方法
        // 优点：不适用临时变量，缺点：1.有可能超出数据限制，2，仅能使用与数字类型，不能使用String等的交换
//        a = a+b;
//        b = a-b;
//        a = a -b;
//        System.out.println("a = "+a+",b="+b);

        // 使用^运算 ，仅使用与整数类型
        a = a^b;
        b = a^b;
        a = a^b;
        System.out.println("a = "+a+",b="+b);	
		
		
数组 
	1.数组存放同样类型的数据(可以是基本类型的也可以是引用类型的数据)
	2.数组存放数据有一定的顺序
	3.数组在内存中的空间是连续的
	4.数组空间大小一旦确定不可更改
	
	
	public static void test4(){
        // 动态初始化，堆，栈，内存分布情况
        int[] a = new int[5];
        // 静态初始化
        int[] a1 = new int[]{2, 3, 4, 5};
        // 怎么理解该情况
        int[] a2 = {};
        System.out.println("a2 " + a2);
        // 类型推断
        int[] a3 = {1,2,5,};
        int[] a4;
        a4 = new int[4];
        // 下面先声明，后初始化为什么不能使用类型推断
//        int[] a5;
//        a5 = {1,2,3};
    }
	
二维数组
	
	
	public static void  test1(){
        // 二维数组
        int[][] a1 = new int[5][4];
        int[][] a2 = {{1,2,3},{1,2},{},{5}};
        int[][] a3;
        a3 = new int[12][];
//        int[][] a4;
//        a4 = {{1,2},{2,3},{4,5}}

        String[][] st1 = new String[5][];
        System.out.println(st1);
        System.out.println(st1[0]);
        System.out.println(a3[1]);
        System.out.println(a2[1]);
		System.out.println(a2[0].length);
    }

数组 
	二维数组
	// 如何理解y的赋值
	int[]x,y[];
	
	public static void test2(){
        // 特别要注意x是一维数组，y是二位数组
        int[]x,y[],z;
        x = new int[]{1, 2, 3, 4};
        y = new int[][]{{1, 2, 3,}, {2, 3}};
    }

数组的算法

	/**
     * 杨辉三角，首尾元素都为1，其他元素满足y[i][j]=y[i-1][y-1]+y[i-1][y]
     */
    public static void test4(){
        // 1.杨辉三角初始化
        int[][] yangHui = new int[10][];
//        yangHui[0] = new int[1];
//        yangHui[1] = new int[2];
//        yangHui[2] = new int[3];

        // 2.赋值
        for (int i = 0; i < yangHui.length; i++) {
            // 2.1初始化数组
            yangHui[i] = new int[i+1];
            // 2.2首尾元素赋值
            yangHui[i][0] = 1;
            yangHui[i][i] = 1;
            
            // 2.3其他数据元素赋值
            if (i>1){
                for (int j = 1; j < yangHui[i].length-1; j++) {
                    yangHui[i][j] = yangHui[i-1][j-1] + yangHui[i-1][j];
                }
            }
        }
        // 3.遍历所有元素
        for (int i = 0; i < yangHui.length; i++) {
            for (int j = 0; j < yangHui[i].length; j++) {
                System.out.print(yangHui[i][j]+"\t");
            }
            System.out.println();
        }
    }
	
	/**
     * 一个为10的数组，元素是两位数的正整数随机数，求该数组的最大值，最小值，和以及平均值
     * [10,99] ，计算公式(int)(Math.random()*(99-10+1)+10)
     */
    public static void test5(){
        int[] numbers = new int[10];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = (int) (Math.random() * (99 - 10 + 1) + 10);
            System.out.print(numbers[i]+"\t");
        }
        int maxValue = numbers[0];
        for (int i = 0; i < numbers.length; i++) {
            if (maxValue<numbers[i]){
                maxValue = numbers[i];
            }
        }
        System.out.println();
        System.out.println("最大值是："+maxValue);
        int minValue = numbers[0];
        for (int i = 0; i < numbers.length; i++) {
            if (minValue>numbers[i]){
                minValue = numbers[i];
            }
        }
        System.out.println("最小值是："+minValue);

        int sum = 0;
        for (int i = 0; i < numbers.length; i++) {
            sum += numbers[i];
        }
        System.out.println("和是："+sum);

        int avg = sum/numbers.length;
        System.out.println("平均值是："+avg);
    }
	
	/**
     * 数组之间相互赋值，复制的区别
     */
    public static void test6(){
        int[] arry1 = new int[]{1,9,8,23,84,43,29};
        for (int i = 0; i < arry1.length; i++) {
            System.out.print(arry1[i]+"\t");
        }
        System.out.println();
        int[] arry2 = arry1;
//        // 修改数组arr2中偶数索引为索引值，例如 i[0]=0,i[2]=2
//        for (int i = 0; i < arry2.length; i++) {
//            if (i%2==0){
//                arry2[i] = i;
//            }
//        }

        // 复制
        int[] arry3 = new int[arry1.length];
        for (int i = 0; i < arry3.length; i++) {
            arry3[i] = arry1[i];
        }

        for (int i = 0; i < arry1.length; i++) {
            System.out.print(arry1[i]+"\t");
        }
    }
	
	/**
     * 数组元素反转
     */
    public static void test7(){
        String[] str1 = new String[] {"JJ","DD","BB","AA","LL","GG","WW","TT","NN","UU","II","RR"};
        // 第一种方案 temp临时变量
//        for (int i = 0; i < str1.length/2; i++) {
//            String temp = str1[i];
//            str1[i] = str1[str1.length-1-i];
//            str1[str1.length-1-i] = temp;
//        }
//        for (int i = 0; i < str1.length; i++) {
//            System.out.print(str1[i]+"\t");
//        }
//        System.out.println();

        // 第二种方案 从两边向中间比较
        for (int i = 0,j= str1.length-1;i<j;i++,j--){
            String temp = str1[i];
            str1[i] = str1[j];
            str1[j] = temp;
        }

        for (int i = 0; i < str1.length; i++) {
            System.out.print(str1[i]+"\t");
        }
        System.out.println();
    }
	
	 /**
     * 数组查找方法，线性查找，二分法查找
     */
    public static void test8(){
        String[] str = new String[]{"JJ","DD","BB","AA","LL","GG","WW","TT","NN","UU","II","RR"};

        // 线性查找
        String dest = "GG";
        boolean isFlag = true;
        for (int i = 0; i < str.length; i++) {
            if (dest.equals(str[i])){
                System.out.println("查找到指定元素的坐标是 " + i);
                isFlag = false;
                break;
            }
        }
        if (isFlag) {
            System.out.println("没有查找到指定的元素");
        }
    }


	/**
     * 二分法查找，注意使用该二分法必须按照一定的顺序排序后才可以使用
     */
    public static void test9(){
        int[] num = {-89,-56,-45,-38,-21,-9,12,24,36,48,59,66,78,83,91,99};
        int dest = 36;
        // 首位索引
        int head = 0;
        // 尾位索引
        int end = num.length - 1;
        boolean isFlag = true;
        while (head <= end){
            int middle = (head + end)/2;
            if (dest == num[middle]){
                System.out.println("找到目标数据元素，位置是 " + middle);
                isFlag = false;
                break;
            } else if (num[middle]>dest){
                end = middle -1;
            } else {
                // num[middle]<dest
                head = middle+1;
            }
        }
        if (isFlag) {
            System.out.println("没有查找到该目标元素！");
        }
    }
	
	
	
	// 6个正整数 从随机1-30选取，各个元素都不相同
	  
	 
	// 回形针数组样例
	
	

算法优劣的标注
	时间复杂度
	空间复杂度
	稳定性

	/**
     * 经典算法：冒泡排序，相邻的元素依次比较，前面的数据比后面的数据大则交换，依次运算
     */
    public static void test10(){
        int[] numbers = {-12,-23,-46,9,87,23,-13,-34,-7,43,12,89,99};
        // 大伦次数
        for (int i = 0; i < numbers.length-1; i++) {
            // 每次大伦次下的小对比次数
            for (int j = 0;j< numbers.length-1-i;j++){
                // 判断相邻两个元素的大小关系，前面元素大于后面的元素则交换
                if (numbers[j]>numbers[j+1]){
                    int tmp = numbers[j];
                    numbers[j] = numbers[j+1];
                    numbers[j+1] = tmp;
                }
            }
        }
        // 遍历所有数据
        for (int i = 0; i < numbers.length; i++) {
            System.out.print(numbers[i]+"\t");
        }
    }
	
各个算法之间的对比
	时间复杂度
	空间复杂度
	稳定性
	
	
	最常使用的算法是冒泡排序，快速排序，堆排序等
	
	
经典算法必会
	十种经典算法，杨辉三角，回形针数组
		冒泡排序，选择排序，快速排序，堆排序，插入排序，归并排序等
	
数组常见异常
	ArrayIndexOfBoundsException
	NullPointerException
	

java对象
	类与对象
		类是对象的抽象，对象是类的具体化。
		
	特点：
		多态，继承，封装
		
	JVM内存分布
		堆，栈，方法区，本地方法栈
	

成员变量和局部变量的区别

	相同点：
		1.都是先声明后使用
		2.都有作用域(生命周期)
		3.格式都一样 ，数据类型 变量名=变量值
	不同点：
		1.位置不同
			成员变量位于类下
			局部变量位于方法内，方法形参，构造方法内，构造方法形参，代码块中
		2.默认值不同
			成员变量有默认初始化值
				byte,short,int,long,float,double,char,boolean使用各自的默认初始值
				String,对象，类其他的默认初始化值为null
			局部变量没有初始化值，使用前必须赋值
				特殊情况：方法形参，构造器形参不需要赋值，在调用该办法的时候赋值
		3.权限修饰符不同
			成员变量可以使用private,public,缺省,protect修饰
			局部变量不可以使用权限修饰符（仅使用缺省）
		4.内存位置不同
			成员变量(非static)位于内存中的堆中
			局部变量位于内存中的栈中
		5.生命周期不同	
			成员变量生命周期和对象生命周期一致
			局部变量生命周期在方法，构造器，代码块结束消亡


方法
	权限修饰符 返回值 方法名(){
		方法体
	}

面向对象
	类的设计：属性，方法，构造器，内部类，代码块 
	面向对象的特征：封装，继承，多态 

如何理解面向对象的编程？

栈，堆是在编译是还是在运行是？
	源代码.java文件编译生成.class文件，字节文件在JVM运行时加载Load分配生成内存，即响应的栈，堆等 



如何理解万事万物皆对象
	1.在java语言范畴内，我们都将功能和结构封装到类中，通过类的实例化，调用对象的具体功能。
		Scanner,String,
		文件对象：File
		网络对象：URl
	2.在java与前端html,json,后端数据库等数据交互时，都体现类、对象。
	
匿名对象
	1.该对象没有显式命名变量名，即为匿名变量
	2.匿名对象只可调用一次
	3.使用场景 xxx.method(new Xxxx());
	

	
	
	
		
	
	